-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/Krantz-XRF/contract#readme</a>
@package contract
@version 0.1.0.0

module Language.Contract.AST

-- | Types: Nat, Bool, * -&gt; *
data Type
TUnit :: Type
TNatural :: Type
TBoolean :: Type
TArrow :: Term -> Type -> Type -> Type

-- | Terms of STLC.
data Term
Unit :: Term
Lambda :: Term -> Type -> Term -> Term
App :: Term -> Term -> Term
Assert :: Term -> Term -> Term
Atom :: Natural -> Term
If :: Term -> Term -> Term -> Term
Succ :: Term -> Term
Pred :: Term -> Term
IsZero :: Term -> Term
Natural :: Natural -> Term
Boolean :: Bool -> Term
pattern And :: Term -> Term -> Term
pattern Or :: Term -> Term -> Term
pattern Not :: Term -> Term

-- | Is this term a value?
isValue :: Term -> Bool

-- | Bind to a value.
pattern Value :: Term
liftAtom :: Natural -> Natural -> Term -> Term
instance GHC.Classes.Ord Language.Contract.AST.Type
instance GHC.Classes.Eq Language.Contract.AST.Type
instance GHC.Show.Show Language.Contract.AST.Type
instance GHC.Classes.Ord Language.Contract.AST.Term
instance GHC.Classes.Eq Language.Contract.AST.Term
instance GHC.Show.Show Language.Contract.AST.Term

module Language.Contract.Parser
parseTerm :: String -> Either ParseError Term
parseFile :: String -> String -> Either ParseError [(String, Term)]

module Language.Contract.Pretty
type MonadPretty m = (MonadReader (Int, Natural) m, MonadWriter String m)
newVar :: MonadPretty m => (String -> m a) -> m a
makeVarName :: Natural -> String
paren :: MonadPretty m => Int -> m a -> m a
tellParen :: MonadPretty m => Int -> m a -> m a
prettyType :: MonadPretty m => Type -> m ()
prettyTerm :: MonadPretty m => Term -> m ()
class PrettyPrint a
prettyWith :: PrettyPrint a => Natural -> a -> String
pretty :: PrettyPrint a => a -> String
prettyPrintWith :: PrettyPrint a => Natural -> a -> IO ()
prettyPrint :: PrettyPrint a => a -> IO ()
instance Language.Contract.Pretty.PrettyPrint Language.Contract.AST.Type
instance Language.Contract.Pretty.PrettyPrint Language.Contract.AST.Term
instance Language.Contract.Pretty.PrettyPrint a => Language.Contract.Pretty.PrettyPrint [a]

module Language.Contract.Proof
type MonadCheck m = (MonadSymbolic m, MonadIO m, MonadReader [Var] m)
data Var
VBool :: SBool -> Var
VNat :: SInteger -> Var
VUnit :: Var
VFunc :: (Var -> Var) -> Var
asNat :: Var -> SInteger
asBool :: Var -> SBool
asFunc :: Var -> Var -> Var
freeVar :: (MonadFail m, MonadSymbolic m) => Natural -> Type -> m Var
iteVar :: Var -> Var -> Var -> Var
makeBoolTerm :: [Var] -> Term -> SBool
constrainPremise :: MonadIO m => [Var] -> Term -> SymbolicT m ()
makeTerm :: [Var] -> Term -> Var
pattern Falsified :: ThmResult
isFalsified :: SMTResult -> Bool
pattern Proven :: ThmResult
tryProve :: MonadIO m => [Type] -> [Term] -> Term -> m (Maybe ThmResult)
naiveTryProve :: (MonadFail m, MonadIO m) => [Type] -> [Term] -> Term -> m ()

module Language.Contract.Check
type MonadTypeCheck m = (MonadReader ([Type], [Term]) m, MonadFail m, MonadIO m)
runTypeCheck :: MaybeT (ReaderT ([Type], [Term]) IO) a -> IO (Maybe a)
assert :: MonadFail m => Bool -> m ()
prove :: MonadTypeCheck m => Term -> m ()

-- | The type of a term, within a specific context.
typeOf :: MonadTypeCheck m => Term -> m Type

-- | One-step evaluation of a term.
eval1 :: [Term] -> Term -> Term

-- | Full evaluation of a term.
evalWith :: [Term] -> Term -> Term

-- | Full evaluation of a term.
eval :: Term -> Term
