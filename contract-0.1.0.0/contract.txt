-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/Krantz-XRF/contract#readme</a>
@package contract
@version 0.1.0.0


module Language.Contract.AST

-- | Types: Nat, Bool, * -&gt; *
data Type
TUnit :: Type
TNatural :: Type
TBoolean :: Type
TArrow :: Term -> Type -> Type -> Type

-- | Terms of STLC.
data Term
Unit :: Term
Lambda :: Term -> Type -> Term -> Term
App :: Term -> Term -> Term
Assert :: Term -> Term -> Term
Atom :: Natural -> Term
If :: Term -> Term -> Term -> Term
Succ :: Term -> Term
Pred :: Term -> Term
IsZero :: Term -> Term
Natural :: Natural -> Term
Boolean :: Bool -> Term

-- | <pre>
--   x &amp; y = if x then y else false
--   </pre>
pattern And :: Term -> Term -> Term

-- | <pre>
--   x | y = if x then true else y
--   </pre>
pattern Or :: Term -> Term -> Term

-- | <pre>
--   not x = if x then false else true
--   </pre>
pattern Not :: Term -> Term

-- | Is this term a value?
isValue :: Term -> Bool

-- | Bind to a value.
pattern Value :: Term

-- | The lift operation of de Bruijn notation.
liftAtom :: Natural -> Natural -> Term -> Term
instance GHC.Classes.Ord Language.Contract.AST.Type
instance GHC.Classes.Eq Language.Contract.AST.Type
instance GHC.Show.Show Language.Contract.AST.Type
instance GHC.Classes.Ord Language.Contract.AST.Term
instance GHC.Classes.Eq Language.Contract.AST.Term
instance GHC.Show.Show Language.Contract.AST.Term


module Language.Contract.Parser

-- | Parse a term, for parsing many terms see <a>parseFile</a>.
parseTerm :: String -> Either ParseError Term

-- | Parse a file, bindings in the form <tt>let <a>name</a> =
--   <a>term</a>;</tt>.
parseFile :: String -> String -> Either ParseError [(String, Term)]


module Language.Contract.Pretty

-- | Make a variable name from its internal index.
makeVarName :: Natural -> String

-- | Pretty show for terms and types.
class PrettyPrint a

-- | Pretty show provided the number of layers of lambda abstractions.
prettyWith :: PrettyPrint a => Natural -> a -> String

-- | Pretty show assuming no outside lambda abstractions.
pretty :: PrettyPrint a => a -> String

-- | Pretty print, a <a>putStrLn</a> after a <a>prettyWith</a>.
prettyPrintWith :: PrettyPrint a => Natural -> a -> IO ()

-- | Pretty print, a <a>putStrLn</a> after a <a>pretty</a>.
prettyPrint :: PrettyPrint a => a -> IO ()
instance Language.Contract.Pretty.PrettyPrint Language.Contract.AST.Type
instance Language.Contract.Pretty.PrettyPrint Language.Contract.AST.Term
instance Language.Contract.Pretty.PrettyPrint a => Language.Contract.Pretty.PrettyPrint [a]


module Language.Contract.Proof

-- | A falsified theorem.
pattern Falsified :: ThmResult

-- | A proven theorem.
pattern Proven :: ThmResult

-- | Is this theorem falsified?
isFalsified :: SMTResult -> Bool

-- | Try prove with sbv.
tryProve :: MonadIO m => [Type] -> [Term] -> Term -> m (Maybe ThmResult)

-- | Use the naive theorem prover.
naiveTryProve :: (MonadFail m, MonadIO m) => [Type] -> [Term] -> Term -> m ()


module Language.Contract.Check

-- | Type checker monad.
type MonadTypeCheck m = (MonadReader ([Type], [Term]) m, MonadFail m, MonadIO m)

-- | Run the type checker monad, get a <a>Maybe</a> result.
runTypeCheck :: MaybeT (ReaderT ([Type], [Term]) IO) a -> IO (Maybe a)

-- | Assertion, fail with <a>MonadFail</a>. <a>guard</a> from Prelude uses
--   Alternative, so not suitable here.
assert :: MonadFail m => Bool -> m ()

-- | Prove a term in the type checker monad.
prove :: MonadTypeCheck m => Term -> m ()

-- | The type of a term, within a specific context.
typeOf :: MonadTypeCheck m => Term -> m Type

-- | One-step evaluation of a term.
eval1 :: [Term] -> Term -> Term

-- | Full evaluation of a term.
evalWith :: [Term] -> Term -> Term

-- | Full evaluation of a term.
eval :: Term -> Term
