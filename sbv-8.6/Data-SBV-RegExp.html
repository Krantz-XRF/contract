<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.SBV.RegExp</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">sbv-8.6: SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.</span><ul class="links" id="page-menu"><li><a href="src/Data.SBV.RegExp.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Levent Erkok</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>erkokl@gmail.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.SBV.RegExp</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Regular expressions</a></li><li><a href="#g:2">Matching</a></li><li><a href="#g:3">Constructing regular expressions</a><ul><li><a href="#g:4">Literals</a></li><li><a href="#g:5">A class of characters</a></li><li><a href="#g:6">Spaces</a></li><li><a href="#g:7">Separators</a></li><li><a href="#g:8">Letters</a></li><li><a href="#g:9">Digits</a></li><li><a href="#g:10">Numbers</a></li><li><a href="#g:11">Identifiers</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A collection of regular-expression related utilities. The recommended
 workflow is to import this module qualified as the names of the functions
 are specificly chosen to be common identifiers. Also, it is recommended
 you use the <code>OverloadedStrings</code> extension to allow literal strings to be
 used as symbolic-strings and regular-expressions when working with
 this module.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:RegExp">RegExp</a><ul class="subs"><li>= <a href="#v:Literal">Literal</a> <a href="../base-4.13.0.0/Data-String.html#t:String" title="Data.String">String</a></li><li>| <a href="#v:All">All</a></li><li>| <a href="#v:None">None</a></li><li>| <a href="#v:Range">Range</a> <a href="../base-4.13.0.0/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="../base-4.13.0.0/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li>| <a href="#v:Conc">Conc</a> [<a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a>]</li><li>| <a href="#v:KStar">KStar</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li>| <a href="#v:KPlus">KPlus</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li>| <a href="#v:Opt">Opt</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li>| <a href="#v:Loop">Loop</a> <a href="../base-4.13.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="../base-4.13.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li>| <a href="#v:Union">Union</a> [<a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a>]</li><li>| <a href="#v:Inter">Inter</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:RegExpMatchable">RegExpMatchable</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:match">match</a> :: a -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a></li></ul></li><li class="src short"><a href="#v:exactly">exactly</a> :: <a href="../base-4.13.0.0/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:oneOf">oneOf</a> :: <a href="../base-4.13.0.0/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:newline">newline</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:whiteSpaceNoNewLine">whiteSpaceNoNewLine</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:whiteSpace">whiteSpace</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:tab">tab</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:punctuation">punctuation</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:asciiLetter">asciiLetter</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:asciiLower">asciiLower</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:asciiUpper">asciiUpper</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:digit">digit</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:octDigit">octDigit</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:hexDigit">hexDigit</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:decimal">decimal</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:octal">octal</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:hexadecimal">hexadecimal</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:floating">floating</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li><li class="src short"><a href="#v:identifier">identifier</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Regular expressions</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:RegExp" class="def">RegExp</a> <a href="src/Data.SBV.Core.Symbolic.html#RegExp" class="link">Source</a> <a href="#t:RegExp" class="selflink">#</a></p><div class="doc"><p>Regular expressions. Note that regular expressions themselves are
 concrete, but the <code><a href="Data-SBV-RegExp.html#v:match" title="Data.SBV.RegExp">match</a></code> function from the <code><a href="Data-SBV-RegExp.html#v:RegExpMatchable" title="Data.SBV.RegExp">RegExpMatchable</a></code> class
 can check membership against a symbolic string/character. Also, we
 are preferring a datatype approach here, as opposed to coming up with
 some string-representation; there are way too many alternatives
 already so inventing one isn't a priority. Please get in touch if you
 would like a parser for this type as it might be easier to use.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Literal" class="def">Literal</a> <a href="../base-4.13.0.0/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p>Precisely match the given string</p></td></tr><tr><td class="src"><a id="v:All" class="def">All</a></td><td class="doc"><p>Accept every string</p></td></tr><tr><td class="src"><a id="v:None" class="def">None</a></td><td class="doc"><p>Accept no strings</p></td></tr><tr><td class="src"><a id="v:Range" class="def">Range</a> <a href="../base-4.13.0.0/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="../base-4.13.0.0/Data-Char.html#t:Char" title="Data.Char">Char</a></td><td class="doc"><p>Accept range of characters</p></td></tr><tr><td class="src"><a id="v:Conc" class="def">Conc</a> [<a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a>]</td><td class="doc"><p>Concatenation</p></td></tr><tr><td class="src"><a id="v:KStar" class="def">KStar</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></td><td class="doc"><p>Kleene Star: Zero or more</p></td></tr><tr><td class="src"><a id="v:KPlus" class="def">KPlus</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></td><td class="doc"><p>Kleene Plus: One or more</p></td></tr><tr><td class="src"><a id="v:Opt" class="def">Opt</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></td><td class="doc"><p>Zero or one</p></td></tr><tr><td class="src"><a id="v:Loop" class="def">Loop</a> <a href="../base-4.13.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="../base-4.13.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></td><td class="doc"><p>From <code>n</code> repetitions to <code>m</code> repetitions</p></td></tr><tr><td class="src"><a id="v:Union" class="def">Union</a> [<a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a>]</td><td class="doc"><p>Union of regular expressions</p></td></tr><tr><td class="src"><a id="v:Inter" class="def">Inter</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></td><td class="doc"><p>Intersection of regular expressions</p></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:RegExp">Instances</h4><details id="i:RegExp" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RegExp:Eq:1"></span> <a href="../base-4.13.0.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></span> <a href="src/Data.SBV.Core.Symbolic.html#line-304" class="link">Source</a> <a href="#t:RegExp" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:RegExp:Eq:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-SBV-Core-Symbolic.html">Data.SBV.Core.Symbolic</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="../base-4.13.0.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="../base-4.13.0.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RegExp:Num:2"></span> <a href="../base-4.13.0.0/Prelude.html#t:Num" title="Prelude">Num</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></span> <a href="src/Data.SBV.Core.Symbolic.html#line-312" class="link">Source</a> <a href="#t:RegExp" class="selflink">#</a></td><td class="doc"><p>Regular expressions as a <code><a href="../base-4.13.0.0/Prelude.html#t:Num" title="Prelude">Num</a></code> instance. Note that
 only <code><a href="../base-4.13.0.0/Prelude.html#v:-43-" title="Prelude">+</a></code> (union) and <code><a href="../base-4.13.0.0/Prelude.html#v:-42-" title="Prelude">*</a></code> (concatenation) make sense.</p></td></tr><tr><td colspan="2"><details id="i:id:RegExp:Num:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-SBV-Core-Symbolic.html">Data.SBV.Core.Symbolic</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-43-">(+)</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="#v:-43-" class="selflink">#</a></p><p class="src"><a href="#v:-45-">(-)</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="#v:-45-" class="selflink">#</a></p><p class="src"><a href="#v:-42-">(*)</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="#v:-42-" class="selflink">#</a></p><p class="src"><a href="#v:negate">negate</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="#v:negate" class="selflink">#</a></p><p class="src"><a href="#v:abs">abs</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="#v:abs" class="selflink">#</a></p><p class="src"><a href="#v:signum">signum</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="#v:signum" class="selflink">#</a></p><p class="src"><a href="#v:fromInteger">fromInteger</a> :: <a href="../base-4.13.0.0/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="#v:fromInteger" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RegExp:Ord:3"></span> <a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></span> <a href="src/Data.SBV.Core.Symbolic.html#line-304" class="link">Source</a> <a href="#t:RegExp" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:RegExp:Ord:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-SBV-Core-Symbolic.html">Data.SBV.Core.Symbolic</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:compare">compare</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="../base-4.13.0.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="#v:compare" class="selflink">#</a></p><p class="src"><a href="#v:-60-">(&lt;)</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="../base-4.13.0.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-60-" class="selflink">#</a></p><p class="src"><a href="#v:-60--61-">(&lt;=)</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="../base-4.13.0.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-60--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62-">(&gt;)</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="../base-4.13.0.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-62-" class="selflink">#</a></p><p class="src"><a href="#v:-62--61-">(&gt;=)</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="../base-4.13.0.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-62--61-" class="selflink">#</a></p><p class="src"><a href="#v:max">max</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="#v:max" class="selflink">#</a></p><p class="src"><a href="#v:min">min</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="#v:min" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RegExp:Show:4"></span> <a href="../base-4.13.0.0/Text-Show.html#t:Show" title="Text.Show">Show</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></span> <a href="src/Data.SBV.Core.Symbolic.html#line-335" class="link">Source</a> <a href="#t:RegExp" class="selflink">#</a></td><td class="doc"><p>Show instance for <code><a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></code>. The mapping is done so the outcome matches the
 SMTLib string reg-exp operations</p></td></tr><tr><td colspan="2"><details id="i:id:RegExp:Show:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-SBV-Core-Symbolic.html">Data.SBV.Core.Symbolic</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="../base-4.13.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="../base-4.13.0.0/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="../base-4.13.0.0/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a>] -&gt; <a href="../base-4.13.0.0/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RegExp:IsString:5"></span> <a href="../base-4.13.0.0/Data-String.html#t:IsString" title="Data.String">IsString</a> <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></span> <a href="src/Data.SBV.Core.Symbolic.html#line-307" class="link">Source</a> <a href="#t:RegExp" class="selflink">#</a></td><td class="doc"><p>With overloaded strings, we can have direct literal regular expressions.</p></td></tr><tr><td colspan="2"><details id="i:id:RegExp:IsString:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-SBV-Core-Symbolic.html">Data.SBV.Core.Symbolic</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fromString">fromString</a> :: <a href="../base-4.13.0.0/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="#v:fromString" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:2" id="g:2"><h1>Matching</h1></a><div class="doc"><p>A symbolic string or a character (<code><a href="Data-SBV-Internals.html#t:SString" title="Data.SBV.Internals">SString</a></code> or <code><a href="Data-SBV-Internals.html#t:SChar" title="Data.SBV.Internals">SChar</a></code>) can be matched against a regular-expression. Note
that the regular-expression itself is not a symbolic object: It's a fully concrete representation, as
captured by the <code><a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></code> class. The <code><a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></code> class is an instance of the <code>IsString</code> class, which makes writing
literal matches easier. The <code><a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></code> type also has a (somewhat degenerate) <code><a href="../base-4.13.0.0/Prelude.html#t:Num" title="Prelude">Num</a></code> instance: Concatenation
corresponds to multiplication, union corresponds to addition, and <code>0</code> corresponds to the empty language.</p><p>Note that since <code><a href="Data-SBV-RegExp.html#v:match" title="Data.SBV.RegExp">match</a></code> is a method of <code><a href="Data-SBV-RegExp.html#t:RegExpMatchable" title="Data.SBV.RegExp">RegExpMatchable</a></code> class, both <code><a href="Data-SBV-Internals.html#t:SChar" title="Data.SBV.Internals">SChar</a></code> and <code><a href="Data-SBV-Internals.html#t:SString" title="Data.SBV.Internals">SString</a></code> can be used as
an argument for matching. In practice, this means you might have to disambiguate with a type-ascription
if it is not deducible from context.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \s -&gt; (s :: SString) `match` &quot;hello&quot; .&lt;=&gt; s .== &quot;hello&quot;
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \s -&gt; s `match` Loop 2 5 &quot;xyz&quot; .=&gt; length s .&gt;= 6
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \s -&gt; s `match` Loop 2 5 &quot;xyz&quot; .=&gt; length s .&lt;= 15
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \s -&gt; match s (Loop 2 5 &quot;xyz&quot;) .=&gt; length s .&gt;= 7
</code></strong>Falsifiable. Counter-example:
  s0 = &quot;xyzxyz&quot; :: String
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \s -&gt; (s :: SString) `match` &quot;hello&quot; .=&gt; s `match` (&quot;hello&quot; + &quot;world&quot;)
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \s -&gt; sNot $ (s::SString) `match` (&quot;so close&quot; * 0)
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; (c :: SChar) `match` oneOf &quot;abcd&quot; .=&gt; ord c .&gt;= ord (literal 'a') .&amp;&amp; ord c .&lt;= ord (literal 'd')
</code></strong>Q.E.D.
</pre></div><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:RegExpMatchable" class="def">RegExpMatchable</a> a <span class="keyword">where</span> <a href="src/Data.SBV.RegExp.html#RegExpMatchable" class="link">Source</a> <a href="#t:RegExpMatchable" class="selflink">#</a></p><div class="doc"><p>Matchable class. Things we can match against a <code><a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a></code>.
 (TODO: Currently SBV does *not* optimize this call if the input is a concrete string or
 a character, but rather directly calls down to the solver. We might want to perform the
 operation on the Haskell side for performance reasons, should this become important.)</p><p>For instance, you can generate valid-looking phone numbers like this:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let dig09 = Range '0' '9'
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let dig19 = Range '1' '9'
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let pre   = dig19 * Loop 2 2 dig09
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let post  = dig19 * Loop 3 3 dig09
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let phone = pre * &quot;-&quot; * post
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sat $ \s -&gt; (s :: SString) `match` phone
</code></strong>Satisfiable. Model:
  s0 = &quot;100-1000&quot; :: String
</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:match" class="def">match</a> :: a -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.RegExp.html#match" class="link">Source</a> <a href="#v:match" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Data-SBV-RegExp.html#v:match" title="Data.SBV.RegExp">match</a></code> s r</code> checks whether <code>s</code> is in the language generated by <code>r</code>.</p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:RegExpMatchable">Instances</h4><details id="i:RegExpMatchable" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:RegExpMatchable:RegExpMatchable:1"></span> <a href="Data-SBV-RegExp.html#t:RegExpMatchable" title="Data.SBV.RegExp">RegExpMatchable</a> <a href="Data-SBV-Internals.html#t:SString" title="Data.SBV.Internals">SString</a></span> <a href="src/Data.SBV.RegExp.html#line-100" class="link">Source</a> <a href="#t:RegExpMatchable" class="selflink">#</a></td><td class="doc"><p>Matching symbolic strings.</p></td></tr><tr><td colspan="2"><details id="i:ic:RegExpMatchable:RegExpMatchable:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-SBV-RegExp.html">Data.SBV.RegExp</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:match">match</a> :: <a href="Data-SBV-Internals.html#t:SString" title="Data.SBV.Internals">SString</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.RegExp.html#match" class="link">Source</a> <a href="#v:match" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:RegExpMatchable:RegExpMatchable:2"></span> <a href="Data-SBV-RegExp.html#t:RegExpMatchable" title="Data.SBV.RegExp">RegExpMatchable</a> <a href="Data-SBV-Internals.html#t:SChar" title="Data.SBV.Internals">SChar</a></span> <a href="src/Data.SBV.RegExp.html#line-96" class="link">Source</a> <a href="#t:RegExpMatchable" class="selflink">#</a></td><td class="doc"><p>Matching a character simply means the singleton string matches the regex.</p></td></tr><tr><td colspan="2"><details id="i:ic:RegExpMatchable:RegExpMatchable:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-SBV-RegExp.html">Data.SBV.RegExp</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:match">match</a> :: <a href="Data-SBV-Internals.html#t:SChar" title="Data.SBV.Internals">SChar</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.RegExp.html#match" class="link">Source</a> <a href="#v:match" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:3" id="g:3"><h1>Constructing regular expressions</h1></a><a href="#g:4" id="g:4"><h2>Literals</h2></a><div class="top"><p class="src"><a id="v:exactly" class="def">exactly</a> :: <a href="../base-4.13.0.0/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#exactly" class="link">Source</a> <a href="#v:exactly" class="selflink">#</a></p><div class="doc"><p>A literal regular-expression, matching the given string exactly. Note that
 with <code>OverloadedStrings</code> extension, you can simply use a Haskell
 string to mean the same thing, so this function is rarely needed.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(s :: SString) -&gt; s `match` exactly &quot;LITERAL&quot; .&lt;=&gt; s .== &quot;LITERAL&quot;
</code></strong>Q.E.D.
</pre></div></div><a href="#g:5" id="g:5"><h2>A class of characters</h2></a><div class="top"><p class="src"><a id="v:oneOf" class="def">oneOf</a> :: <a href="../base-4.13.0.0/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#oneOf" class="link">Source</a> <a href="#v:oneOf" class="selflink">#</a></p><div class="doc"><p>Helper to define a character class.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(c :: SChar) -&gt; c `match` oneOf &quot;ABCD&quot; .&lt;=&gt; sAny (c .==) (map literal &quot;ABCD&quot;)
</code></strong>Q.E.D.
</pre></div></div><a href="#g:6" id="g:6"><h2>Spaces</h2></a><div class="top"><p class="src"><a id="v:newline" class="def">newline</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#newline" class="link">Source</a> <a href="#v:newline" class="selflink">#</a></p><div class="doc"><p>Recognize a newline. Also includes carriage-return and form-feed.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>newline
</code></strong>(re.union (str.to.re &quot;\n&quot;) (str.to.re &quot;\r&quot;) (str.to.re &quot;\f&quot;))
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` newline .=&gt; isSpace c
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:whiteSpaceNoNewLine" class="def">whiteSpaceNoNewLine</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#whiteSpaceNoNewLine" class="link">Source</a> <a href="#v:whiteSpaceNoNewLine" class="selflink">#</a></p><div class="doc"><p>Recognize white-space, but without a new line.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>whiteSpaceNoNewLine
</code></strong>(re.union (str.to.re &quot;\x09&quot;) (re.union (str.to.re &quot;\v&quot;) (str.to.re &quot;\xa0&quot;) (str.to.re &quot; &quot;)))
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` whiteSpaceNoNewLine .=&gt; c `match` whiteSpace .&amp;&amp; c ./= literal '\n'
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:whiteSpace" class="def">whiteSpace</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#whiteSpace" class="link">Source</a> <a href="#v:whiteSpace" class="selflink">#</a></p><div class="doc"><p>Recognize white space.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` whiteSpace .=&gt; isSpace c
</code></strong>Q.E.D.
</pre></div></div><a href="#g:7" id="g:7"><h2>Separators</h2></a><div class="top"><p class="src"><a id="v:tab" class="def">tab</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#tab" class="link">Source</a> <a href="#v:tab" class="selflink">#</a></p><div class="doc"><p>Recognize a tab.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>tab
</code></strong>(str.to.re &quot;\x09&quot;)
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` tab .=&gt; c .== literal '\t'
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:punctuation" class="def">punctuation</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#punctuation" class="link">Source</a> <a href="#v:punctuation" class="selflink">#</a></p><div class="doc"><p>Recognize a punctuation character. Anything that satisfies the predicate <code><a href="Data-SBV-Char.html#v:isPunctuation" title="Data.SBV.Char">isPunctuation</a></code> will
 be accepted.  (TODO: Will need modification when we move to unicode.)</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` punctuation .=&gt; isPunctuation c
</code></strong>Q.E.D.
</pre></div></div><a href="#g:8" id="g:8"><h2>Letters</h2></a><div class="top"><p class="src"><a id="v:asciiLetter" class="def">asciiLetter</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#asciiLetter" class="link">Source</a> <a href="#v:asciiLetter" class="selflink">#</a></p><div class="doc"><p>Recognize an alphabet letter, i.e., <code>A</code>..<code>Z</code>, <code>a</code>..<code>z</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>asciiLetter
</code></strong>(re.union (re.range &quot;a&quot; &quot;z&quot;) (re.range &quot;A&quot; &quot;Z&quot;))
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` asciiLetter .&lt;=&gt; toUpper c `match` asciiLetter
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` asciiLetter .&lt;=&gt; toLower c `match` asciiLetter
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:asciiLower" class="def">asciiLower</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#asciiLower" class="link">Source</a> <a href="#v:asciiLower" class="selflink">#</a></p><div class="doc"><p>Recognize an ASCII lower case letter</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>asciiLower
</code></strong>(re.range &quot;a&quot; &quot;z&quot;)
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; (c :: SChar) `match` asciiLower  .=&gt; c `match` asciiLetter
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` asciiLower  .=&gt; toUpper c `match` asciiUpper
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` asciiLetter .=&gt; toLower c `match` asciiLower
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:asciiUpper" class="def">asciiUpper</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#asciiUpper" class="link">Source</a> <a href="#v:asciiUpper" class="selflink">#</a></p><div class="doc"><p>Recognize an upper case letter</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>asciiUpper
</code></strong>(re.range &quot;A&quot; &quot;Z&quot;)
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; (c :: SChar) `match` asciiUpper  .=&gt; c `match` asciiLetter
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` asciiUpper  .=&gt; toLower c `match` asciiLower
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` asciiLetter .=&gt; toUpper c `match` asciiUpper
</code></strong>Q.E.D.
</pre></div></div><a href="#g:9" id="g:9"><h2>Digits</h2></a><div class="top"><p class="src"><a id="v:digit" class="def">digit</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#digit" class="link">Source</a> <a href="#v:digit" class="selflink">#</a></p><div class="doc"><p>Recognize a digit. One of <code>0</code>..<code>9</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>digit
</code></strong>(re.range &quot;0&quot; &quot;9&quot;)
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` digit .&lt;=&gt; let v = digitToInt c in 0 .&lt;= v .&amp;&amp; v .&lt; 10
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:octDigit" class="def">octDigit</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#octDigit" class="link">Source</a> <a href="#v:octDigit" class="selflink">#</a></p><div class="doc"><p>Recognize an octal digit. One of <code>0</code>..<code>7</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>octDigit
</code></strong>(re.range &quot;0&quot; &quot;7&quot;)
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` octDigit .&lt;=&gt; let v = digitToInt c in 0 .&lt;= v .&amp;&amp; v .&lt; 8
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(c :: SChar) -&gt; c `match` octDigit .=&gt; c `match` digit
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:hexDigit" class="def">hexDigit</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#hexDigit" class="link">Source</a> <a href="#v:hexDigit" class="selflink">#</a></p><div class="doc"><p>Recognize a hexadecimal digit. One of <code>0</code>..<code>9</code>, <code>a</code>..<code>f</code>, <code>A</code>..<code>F</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>hexDigit
</code></strong>(re.union (re.range &quot;0&quot; &quot;9&quot;) (re.range &quot;a&quot; &quot;f&quot;) (re.range &quot;A&quot; &quot;F&quot;))
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \c -&gt; c `match` hexDigit .&lt;=&gt; let v = digitToInt c in 0 .&lt;= v .&amp;&amp; v .&lt; 16
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(c :: SChar) -&gt; c `match` digit .=&gt; c `match` hexDigit
</code></strong>Q.E.D.
</pre></div></div><a href="#g:10" id="g:10"><h2>Numbers</h2></a><div class="top"><p class="src"><a id="v:decimal" class="def">decimal</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#decimal" class="link">Source</a> <a href="#v:decimal" class="selflink">#</a></p><div class="doc"><p>Recognize a decimal number.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>decimal
</code></strong>(re.+ (re.range &quot;0&quot; &quot;9&quot;))
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \s -&gt; (s::SString) `match` decimal .=&gt; sNot (s `match` KStar asciiLetter)
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:octal" class="def">octal</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#octal" class="link">Source</a> <a href="#v:octal" class="selflink">#</a></p><div class="doc"><p>Recognize an octal number. Must have a prefix of the form <code>0o</code>/<code>0O</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>octal
</code></strong>(re.++ (re.union (str.to.re &quot;0o&quot;) (str.to.re &quot;0O&quot;)) (re.+ (re.range &quot;0&quot; &quot;7&quot;)))
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \s -&gt; s `match` octal .=&gt; sAny (.== take 2 s) [&quot;0o&quot;, &quot;0O&quot;]
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:hexadecimal" class="def">hexadecimal</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#hexadecimal" class="link">Source</a> <a href="#v:hexadecimal" class="selflink">#</a></p><div class="doc"><p>Recognize a hexadecimal number. Must have a prefix of the form <code>0x</code>/<code>0X</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>hexadecimal
</code></strong>(re.++ (re.union (str.to.re &quot;0x&quot;) (str.to.re &quot;0X&quot;)) (re.+ (re.union (re.range &quot;0&quot; &quot;9&quot;) (re.range &quot;a&quot; &quot;f&quot;) (re.range &quot;A&quot; &quot;F&quot;))))
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \s -&gt; s `match` hexadecimal .=&gt; sAny (.== take 2 s) [&quot;0x&quot;, &quot;0X&quot;]
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:floating" class="def">floating</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#floating" class="link">Source</a> <a href="#v:floating" class="selflink">#</a></p><div class="doc"><p>Recognize a floating point number. The exponent part is optional if a fraction
 is present. The exponent may or may not have a sign.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \s -&gt; s `match` floating .=&gt; length s .&gt;= 3
</code></strong>Q.E.D.
</pre></div></div><a href="#g:11" id="g:11"><h2>Identifiers</h2></a><div class="top"><p class="src"><a id="v:identifier" class="def">identifier</a> :: <a href="Data-SBV-RegExp.html#t:RegExp" title="Data.SBV.RegExp">RegExp</a> <a href="src/Data.SBV.RegExp.html#identifier" class="link">Source</a> <a href="#v:identifier" class="selflink">#</a></p><div class="doc"><p>For the purposes of this regular expression, an identifier consists of a letter
 followed by zero or more letters, digits, underscores, and single quotes. The first
 letter must be lowercase.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \s -&gt; s `match` identifier .=&gt; isAsciiLower (head s)
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \s -&gt; s `match` identifier .=&gt; length s .&gt;= 1
</code></strong>Q.E.D.
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>