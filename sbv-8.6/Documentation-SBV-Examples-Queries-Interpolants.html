<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Documentation.SBV.Examples.Queries.Interpolants</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">sbv-8.6: SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.</span><ul class="links" id="page-menu"><li><a href="src/Documentation.SBV.Examples.Queries.Interpolants.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Levent Erkok</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>erkokl@gmail.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Documentation.SBV.Examples.Queries.Interpolants</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Demonstrates extraction of interpolants via queries.</p><p>N.B. Interpolants are supported by MathSAT and Z3. Unfortunately
 the extraction of interpolants is not standardized, and are slightly
 different for these two solvers. So, we have two separate examples
 to demonstrate the usage.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:exampleMathSAT">exampleMathSAT</a> :: <a href="Data-SBV-Internals.html#t:Symbolic" title="Data.SBV.Internals">Symbolic</a> <a href="../base-4.13.0.0/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:evenOdd">evenOdd</a> :: <a href="Data-SBV-Internals.html#t:Symbolic" title="Data.SBV.Internals">Symbolic</a> <a href="../base-4.13.0.0/Data-String.html#t:String" title="Data.String">String</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:exampleMathSAT" class="def">exampleMathSAT</a> :: <a href="Data-SBV-Internals.html#t:Symbolic" title="Data.SBV.Internals">Symbolic</a> <a href="../base-4.13.0.0/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Documentation.SBV.Examples.Queries.Interpolants.html#exampleMathSAT" class="link">Source</a> <a href="#v:exampleMathSAT" class="selflink">#</a></p><div class="doc"><p>MathSAT example. Compute the interpolant for the following sets of formulas:</p><pre>{x - 3y &gt;= -1, x + y &gt;= 0}</pre><p>AND</p><pre>{z - 2x &gt;= 3, 2z &lt;= 1}</pre><p>where the variables are integers.  Note that these sets of
 formulas are themselves satisfiable, but not taken all together.
 The pair <code>(x, y) = (0, 0)</code> satisfies the first set. The pair <code>(x, z) = (-2, 0)</code>
 satisfies the second. However, there's no triple <code>(x, y, z)</code> that satisfies all
 these four formulas together. We can use SBV to check this fact:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sat $ \x y z -&gt; sAnd [x - 3*y .&gt;= -1, x + y .&gt;= 0, z - 2*x .&gt;= 3, 2 * z .&lt;= (1::SInteger)]
</code></strong>Unsatisfiable
</pre><p>An interpolant for these sets would only talk about the variable <code>x</code> that is common
 to both. We have:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runSMTWith mathSAT exampleMathSAT
</code></strong>&quot;(&lt;= 0 s0)&quot;
</pre><p>Notice that we get a string back, not a term; so there's some back-translation we need to do. We
 know that <code>s0</code> is <code>x</code> through our translation mechanism, so the interpolant is saying that <code>x &gt;= 0</code>
 is entailed by the first set of formulas, and is inconsistent with the second. Let's use SBV
 to indeed show that this is the case:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x y -&gt; (x - 3*y .&gt;= -1 .&amp;&amp; x + y .&gt;= 0) .=&gt; (x .&gt;= (0::SInteger))
</code></strong>Q.E.D.
</pre><p>And:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x z -&gt; (z - 2*x .&gt;= 3 .&amp;&amp; 2 * z .&lt;= 1) .=&gt; sNot (x .&gt;= (0::SInteger))
</code></strong>Q.E.D.
</pre><p>This establishes that we indeed have an interpolant!</p></div></div><div class="top"><p class="src"><a id="v:evenOdd" class="def">evenOdd</a> :: <a href="Data-SBV-Internals.html#t:Symbolic" title="Data.SBV.Internals">Symbolic</a> <a href="../base-4.13.0.0/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Documentation.SBV.Examples.Queries.Interpolants.html#evenOdd" class="link">Source</a> <a href="#v:evenOdd" class="selflink">#</a></p><div class="doc"><p>Z3 example. Compute the interpolant for formulas <code>y = 2x</code> and <code>y = 2z+1</code>.</p><p>These formulas are not satisfiable together since it would mean
 <code>y</code> is both even and odd at the same time. An interpolant for
 this pair of formulas is a formula that's expressed only in terms
 of <code>y</code>, which is the only common symbol among them. We have:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runSMT evenOdd
</code></strong>&quot;(or (= s1 0) (= s1 (* 2 (div s1 2))))&quot;
</pre><p>This is a bit hard to read unfortunately, due to translation artifacts and use of strings. To analyze,
 we need to know that <code>s1</code> is <code>y</code> through SBV's translation. Let's express it in
 regular infix notation with <code>y</code> for <code>s1</code>:</p><pre>(y == 0) || (y == 2 * (y <code><a href="../base-4.13.0.0/Prelude.html#v:div" title="Prelude">div</a></code> 2))</pre><p>Notice that the only symbol is <code>y</code>, as required. To establish that this is
 indeed an interpolant, we should establish that when <code>y</code> is even, this formula
 is <code>True</code>; and if <code>y</code> is odd, then then it should be <code>False</code>. You can argue
 mathematically that this indeed the case, but let's just use SBV to prove these:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \y -&gt; (y `sMod` 2 .== 0) .=&gt; ((y .== 0) .|| (y .== 2 * (y `sDiv` (2::SInteger))))
</code></strong>Q.E.D.
</pre><p>And:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \y -&gt; (y `sMod` 2 .== 1) .=&gt; sNot ((y .== 0) .|| (y .== 2 * (y `sDiv` (2::SInteger))))
</code></strong>Q.E.D.
</pre><p>This establishes that we indeed have an interpolant!</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>