<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.SBV.Set</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">sbv-8.6: SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.</span><ul class="links" id="page-menu"><li><a href="src/Data.SBV.Set.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Levent Erkok</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>erkokl@gmail.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.SBV.Set</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Constructing sets</a></li><li><a href="#g:2">Equality of sets</a></li><li><a href="#g:3">Insertion and deletion</a></li><li><a href="#g:4">Query</a></li><li><a href="#g:5">Combinations</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A collection of set utilities, useful when working with symbolic sets.
 To the extent possible, the functions in this module follow those
 of <a href="../containers-0.6.2.1/Data-Set.html">Data.Set</a> so importing qualified is the recommended workflow.</p><p>Note that unlike <a href="../containers-0.6.2.1/Data-Set.html">Data.Set</a>, SBV sets can be infinite, represented
 as a complement of some finite set. This means that a symbolic set
 is either finite, or its complement is finite. (If the underlying
 domain is finite, then obviously both the set itself and its complement
 will always be finite.) Therefore, there are some differences in the API
 from Haskell sets. For instance, you can take the complement of any set,
 which is something you cannot do in Haskell! Conversely, you cannot compute
 the size of a symbolic set (as it can be infinite!), nor you can turn
 it into a list or necessarily enumerate its elements.</p><p><strong>A note on cardinality</strong>: You can indirectly talk about cardinality: <code><a href="Data-SBV-Set.html#v:hasSize" title="Data.SBV.Set">hasSize</a></code>
 can be used to state that the set is finite and has size <code>k</code> for a user-specified symbolic
 integer <code>k</code>.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:empty">empty</a> :: <span class="keyword">forall</span> a. <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:full">full</a> :: <span class="keyword">forall</span> a. <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:universal">universal</a> :: <span class="keyword">forall</span> a. <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:singleton">singleton</a> :: <span class="keyword">forall</span> a. (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SBV" title="Data.SBV.Internals">SBV</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:fromList">fromList</a> :: <span class="keyword">forall</span> a. (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; [a] -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:complement">complement</a> :: <span class="keyword">forall</span> a. (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:insert">insert</a> :: <span class="keyword">forall</span> a. (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SBV" title="Data.SBV.Internals">SBV</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:delete">delete</a> :: <span class="keyword">forall</span> a. (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SBV" title="Data.SBV.Internals">SBV</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:member">member</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SBV" title="Data.SBV.Internals">SBV</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a></li><li class="src short"><a href="#v:notMember">notMember</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SBV" title="Data.SBV.Internals">SBV</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a></li><li class="src short"><a href="#v:null">null</a> :: <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a></li><li class="src short"><a href="#v:isEmpty">isEmpty</a> :: <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a></li><li class="src short"><a href="#v:isFull">isFull</a> :: <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a></li><li class="src short"><a href="#v:isUniversal">isUniversal</a> :: <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a></li><li class="src short"><a href="#v:hasSize">hasSize</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SInteger" title="Data.SBV.Internals">SInteger</a> -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a></li><li class="src short"><a href="#v:isSubsetOf">isSubsetOf</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a></li><li class="src short"><a href="#v:isProperSubsetOf">isProperSubsetOf</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a></li><li class="src short"><a href="#v:disjoint">disjoint</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a></li><li class="src short"><a href="#v:union">union</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:unions">unions</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; [<a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a] -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:intersection">intersection</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:intersections">intersections</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; [<a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a] -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:difference">difference</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li><li class="src short"><a href="#v:-92--92-">(\\)</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Constructing sets</h1></a><div class="top"><p class="src"><a id="v:empty" class="def">empty</a> :: <span class="keyword">forall</span> a. <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#empty" class="link">Source</a> <a href="#v:empty" class="selflink">#</a></p><div class="doc"><p>Empty set.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>empty :: SSet Integer
</code></strong>{} :: {SInteger}
</pre></div></div><div class="top"><p class="src"><a id="v:full" class="def">full</a> :: <span class="keyword">forall</span> a. <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#full" class="link">Source</a> <a href="#v:full" class="selflink">#</a></p><div class="doc"><p>Full set.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>full :: SSet Integer
</code></strong>U :: {SInteger}
</pre><p>Note that the universal set over a type is represented by the letter <code>U</code>.</p></div></div><div class="top"><p class="src"><a id="v:universal" class="def">universal</a> :: <span class="keyword">forall</span> a. <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#universal" class="link">Source</a> <a href="#v:universal" class="selflink">#</a></p><div class="doc"><p>Synonym for <code><a href="Data-SBV-Set.html#v:full" title="Data.SBV.Set">full</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:singleton" class="def">singleton</a> :: <span class="keyword">forall</span> a. (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SBV" title="Data.SBV.Internals">SBV</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#singleton" class="link">Source</a> <a href="#v:singleton" class="selflink">#</a></p><div class="doc"><p>Singleton list.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>singleton 2 :: SSet Integer
</code></strong>{2} :: {SInteger}
</pre></div></div><div class="top"><p class="src"><a id="v:fromList" class="def">fromList</a> :: <span class="keyword">forall</span> a. (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; [a] -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#fromList" class="link">Source</a> <a href="#v:fromList" class="selflink">#</a></p><div class="doc"><p>Conversion from a list.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fromList ([] :: [Integer])
</code></strong>{} :: {SInteger}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fromList [1,2,3]
</code></strong>{1,2,3} :: {SInteger}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fromList [5,5,5,12,12,3]
</code></strong>{3,5,12} :: {SInteger}
</pre></div></div><div class="top"><p class="src"><a id="v:complement" class="def">complement</a> :: <span class="keyword">forall</span> a. (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#complement" class="link">Source</a> <a href="#v:complement" class="selflink">#</a></p><div class="doc"><p>Complement.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>empty .== complement (full :: SSet Integer)
</code></strong>True
</pre><p>Complementing twice gets us back the original set:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(s :: SSet Integer) -&gt; complement (complement s) .== s
</code></strong>Q.E.D.
</pre></div></div><a href="#g:2" id="g:2"><h1>Equality of sets</h1></a><div class="doc"><p>We can compare sets for equality:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>empty .== (empty :: SSet Integer)
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>full .== (full :: SSet Integer)
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>full ./= (full :: SSet Integer)
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sat $ \(x::SSet (Maybe Integer)) y z -&gt; distinct [x, y, z]
</code></strong>Satisfiable. Model:
  s0 = U - {Just 0} :: {Maybe Integer}
  s1 =           {} :: {Maybe Integer}
  s2 =            U :: {Maybe Integer}
</pre><p>However, if we compare two sets that are constructed as regular or in the complement
form, we have to use a proof to establish equality:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ full .== (empty :: SSet Integer)
</code></strong>Falsifiable
</pre><p>The reason for this is that there is no way in Haskell to compare an infinite
set to any other set, as infinite sets are not representable at all! So, we have
to delay the judgment to the SMT solver. If you try to constant fold, you
will get:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>full .== (empty :: SSet Integer)
</code></strong>&lt;symbolic&gt; :: SBool
</pre><p>indicating that the result is a symbolic value that needs a decision
procedure to be determined!</p></div><a href="#g:3" id="g:3"><h1>Insertion and deletion</h1></a><div class="top"><p class="src"><a id="v:insert" class="def">insert</a> :: <span class="keyword">forall</span> a. (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SBV" title="Data.SBV.Internals">SBV</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#insert" class="link">Source</a> <a href="#v:insert" class="selflink">#</a></p><div class="doc"><p>Insert an element into a set.</p><p>Insertion is order independent:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x y (s :: SSet Integer) -&gt; x `insert` (y `insert` s) .== y `insert` (x `insert` s)
</code></strong>Q.E.D.
</pre><p>Deletion after insertion is not necessarily identity:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x (s :: SSet Integer) -&gt; x `delete` (x `insert` s) .== s
</code></strong>Falsifiable. Counter-example:
  s0 =   0 :: Integer
  s1 = {0} :: {Integer}
</pre><p>But the above is true if the element isn't in the set to start with:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x (s :: SSet Integer) -&gt; x `notMember` s .=&gt; x `delete` (x `insert` s) .== s
</code></strong>Q.E.D.
</pre><p>Insertion into a full set does nothing:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x -&gt; insert x full .== (full :: SSet Integer)
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:delete" class="def">delete</a> :: <span class="keyword">forall</span> a. (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SBV" title="Data.SBV.Internals">SBV</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#delete" class="link">Source</a> <a href="#v:delete" class="selflink">#</a></p><div class="doc"><p>Delete an element from a set.</p><p>Deletion is order independent:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x y (s :: SSet Integer) -&gt; x `delete` (y `delete` s) .== y `delete` (x `delete` s)
</code></strong>Q.E.D.
</pre><p>Insertion after deletion is not necessarily identity:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x (s :: SSet Integer) -&gt; x `insert` (x `delete` s) .== s
</code></strong>Falsifiable. Counter-example:
  s0 =  0 :: Integer
  s1 = {} :: {Integer}
</pre><p>But the above is true if the element is in the set to start with:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x (s :: SSet Integer) -&gt; x `member` s .=&gt; x `insert` (x `delete` s) .== s
</code></strong>Q.E.D.
</pre><p>Deletion from an empty set does nothing:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x -&gt; delete x empty .== (empty :: SSet Integer)
</code></strong>Q.E.D.
</pre></div></div><a href="#g:4" id="g:4"><h1>Query</h1></a><div class="top"><p class="src"><a id="v:member" class="def">member</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SBV" title="Data.SBV.Internals">SBV</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.Set.html#member" class="link">Source</a> <a href="#v:member" class="selflink">#</a></p><div class="doc"><p>Test for membership.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x -&gt; x `member` singleton (x :: SInteger)
</code></strong>Q.E.D.
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x (s :: SSet Integer) -&gt; x `member` (x `insert` s)
</code></strong>Q.E.D.
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x -&gt; x `member` (full :: SSet Integer)
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:notMember" class="def">notMember</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SBV" title="Data.SBV.Internals">SBV</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.Set.html#notMember" class="link">Source</a> <a href="#v:notMember" class="selflink">#</a></p><div class="doc"><p>Test for non-membership.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x -&gt; x `notMember` observe &quot;set&quot; (singleton (x :: SInteger))
</code></strong>Falsifiable. Counter-example:
  set = {0} :: {Integer}
  s0  =   0 :: Integer
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x (s :: SSet Integer) -&gt; x `notMember` (x `delete` s)
</code></strong>Q.E.D.
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x -&gt; x `notMember` (empty :: SSet Integer)
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:null" class="def">null</a> :: <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.Set.html#null" class="link">Source</a> <a href="#v:null" class="selflink">#</a></p><div class="doc"><p>Is this the empty set?</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>null (empty :: SSet Integer)
</code></strong>True
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x -&gt; null (x `delete` singleton (x :: SInteger))
</code></strong>Q.E.D.
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ null (full :: SSet Integer)
</code></strong>Falsifiable
</pre><p>Note how we have to call <code><a href="Data-SBV.html#v:prove" title="Data.SBV">prove</a></code> in the last case since dealing
 with infinite sets requires a call to the solver and cannot be
 constant folded.</p></div></div><div class="top"><p class="src"><a id="v:isEmpty" class="def">isEmpty</a> :: <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.Set.html#isEmpty" class="link">Source</a> <a href="#v:isEmpty" class="selflink">#</a></p><div class="doc"><p>Synonym for <code><a href="Data-SBV-Set.html#v:null" title="Data.SBV.Set">null</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:isFull" class="def">isFull</a> :: <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.Set.html#isFull" class="link">Source</a> <a href="#v:isFull" class="selflink">#</a></p><div class="doc"><p>Is this the full set?</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ isFull (empty :: SSet Integer)
</code></strong>Falsifiable
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x -&gt; isFull (observe &quot;set&quot; (x `delete` (full :: SSet Integer)))
</code></strong>Falsifiable. Counter-example:
  set = U - {0} :: {Integer}
  s0  =       0 :: Integer
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>isFull (full :: SSet Integer)
</code></strong>True
</pre><p>Note how we have to call <code><a href="Data-SBV.html#v:prove" title="Data.SBV">prove</a></code> in the first case since dealing
 with infinite sets requires a call to the solver and cannot be
 constant folded.</p></div></div><div class="top"><p class="src"><a id="v:isUniversal" class="def">isUniversal</a> :: <a href="Data-SBV-Internals.html#t:HasKind" title="Data.SBV.Internals">HasKind</a> a =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.Set.html#isUniversal" class="link">Source</a> <a href="#v:isUniversal" class="selflink">#</a></p><div class="doc"><p>Synonym for <code><a href="Data-SBV-Set.html#v:isFull" title="Data.SBV.Set">isFull</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:hasSize" class="def">hasSize</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SInteger" title="Data.SBV.Internals">SInteger</a> -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.Set.html#hasSize" class="link">Source</a> <a href="#v:hasSize" class="selflink">#</a></p><div class="doc"><p>Does the set have the given size? It implicitly asserts that the set
 it is operating on is finite. Also see <code><a href="Data-SBV-Set.html#v:card" title="Data.SBV.Set">card</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \i -&gt; hasSize (empty :: SSet Integer) i .== (i .== 0)
</code></strong>Q.E.D.
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sat $ \i -&gt; hasSize (full :: SSet Integer) i
</code></strong>Unsatisfiable
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \a b i j k -&gt; hasSize (a :: SSet Integer) i .&amp;&amp; hasSize (b :: SSet Integer) j .&amp;&amp; hasSize (a `union` b) k .=&gt; k .&gt;= i `smax` j
</code></strong>Q.E.D.
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \a b i j k -&gt; hasSize (a :: SSet Integer) i .&amp;&amp; hasSize (b :: SSet Integer) j .&amp;&amp; hasSize (a `intersection` b) k .=&gt; k .&lt;= i `smin` j
</code></strong>Q.E.D.
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \a k -&gt; hasSize (a :: SSet Integer) k .=&gt; k .&gt;= 0
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:isSubsetOf" class="def">isSubsetOf</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.Set.html#isSubsetOf" class="link">Source</a> <a href="#v:isSubsetOf" class="selflink">#</a></p><div class="doc"><p>Subset test.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ empty `isSubsetOf` (full :: SSet Integer)
</code></strong>Q.E.D.
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x (s :: SSet Integer) -&gt; s `isSubsetOf` (x `insert` s)
</code></strong>Q.E.D.
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x (s :: SSet Integer) -&gt; (x `delete` s) `isSubsetOf` s
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:isProperSubsetOf" class="def">isProperSubsetOf</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.Set.html#isProperSubsetOf" class="link">Source</a> <a href="#v:isProperSubsetOf" class="selflink">#</a></p><div class="doc"><p>Proper subset test.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ empty `isProperSubsetOf` (full :: SSet Integer)
</code></strong>Q.E.D.
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x (s :: SSet Integer) -&gt; s `isProperSubsetOf` (x `insert` s)
</code></strong>Falsifiable. Counter-example:
  s0 = 0 :: Integer
  s1 = U :: {Integer}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x (s :: SSet Integer) -&gt; x `notMember` s .=&gt; s `isProperSubsetOf` (x `insert` s)
</code></strong>Q.E.D.
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x (s :: SSet Integer) -&gt; (x `delete` s) `isProperSubsetOf` s
</code></strong>Falsifiable. Counter-example:
  s0 =         0 :: Integer
  s1 = U - {0,1} :: {Integer}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \x (s :: SSet Integer) -&gt; x `member` s .=&gt; (x `delete` s) `isProperSubsetOf` s
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:disjoint" class="def">disjoint</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Data.SBV.Set.html#disjoint" class="link">Source</a> <a href="#v:disjoint" class="selflink">#</a></p><div class="doc"><p>Disjoint test.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>disjoint (fromList [2,4,6])   (fromList [1,3])
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>disjoint (fromList [2,4,6,8]) (fromList [2,3,5,7])
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>disjoint (fromList [1,2])     (fromList [1,2,3,4])
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(s :: SSet Integer) -&gt; s `disjoint` complement s
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>allSat $ \(s :: SSet Integer) -&gt; s `disjoint` s
</code></strong>Solution #1:
  s0 = {} :: {Integer}
This is the only solution.
</pre><p>The last example is particularly interesting: The empty set is the
 only set where <code><a href="Data-SBV-Set.html#v:disjoint" title="Data.SBV.Set">disjoint</a></code> is not reflexive!</p><p>Note that disjointness of a set from its complement is guaranteed
 by the fact that all types are inhabited; an implicit assumption
 we have in classic logic which is also enjoyed by Haskell due to
 the presence of bottom!</p></div></div><a href="#g:5" id="g:5"><h1>Combinations</h1></a><div class="top"><p class="src"><a id="v:union" class="def">union</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#union" class="link">Source</a> <a href="#v:union" class="selflink">#</a></p><div class="doc"><p>Union.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>union (fromList [1..10]) (fromList [5..15]) .== (fromList [1..15] :: SSet Integer)
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) b -&gt; a `union` b .== b `union` a
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) b c -&gt; a `union` (b `union` c) .== (a `union` b) `union` c
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) -&gt; a `union` full .== full
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) -&gt; a `union` empty .== a
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) -&gt; a `union` complement a .== full
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:unions" class="def">unions</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; [<a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a] -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#unions" class="link">Source</a> <a href="#v:unions" class="selflink">#</a></p><div class="doc"><p>Unions. Equivalent to <code><code><a href="../base-4.13.0.0/Data-Foldable.html#v:foldr" title="Data.Foldable">foldr</a></code> <code><a href="Data-SBV-Set.html#v:union" title="Data.SBV.Set">union</a></code> <code><a href="Data-SBV-Set.html#v:empty" title="Data.SBV.Set">empty</a></code></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ unions [] .== (empty :: SSet Integer)
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:intersection" class="def">intersection</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#intersection" class="link">Source</a> <a href="#v:intersection" class="selflink">#</a></p><div class="doc"><p>Intersection.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>intersection (fromList [1..10]) (fromList [5..15]) .== (fromList [5..10] :: SSet Integer)
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) b -&gt; a `intersection` b .== b `intersection` a
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) b c -&gt; a `intersection` (b `intersection` c) .== (a `intersection` b) `intersection` c
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) -&gt; a `intersection` full .== a
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) -&gt; a `intersection` empty .== empty
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) -&gt; a `intersection` complement a .== empty
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) b -&gt; a `disjoint` b .=&gt; a `intersection` b .== empty
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:intersections" class="def">intersections</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; [<a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a] -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#intersections" class="link">Source</a> <a href="#v:intersections" class="selflink">#</a></p><div class="doc"><p>Intersections. Equivalent to <code><code><a href="../base-4.13.0.0/Data-Foldable.html#v:foldr" title="Data.Foldable">foldr</a></code> <code><a href="Data-SBV-Set.html#v:intersection" title="Data.SBV.Set">intersection</a></code> <code><a href="Data-SBV-Set.html#v:full" title="Data.SBV.Set">full</a></code></code>. Note that
 Haskell's <code><a href="Data.html#v:Set" title="Data">Set</a></code> does not support this operation as it does not have a
 way of representing universal sets.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ intersections [] .== (full :: SSet Integer)
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:difference" class="def">difference</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <a href="src/Data.SBV.Set.html#difference" class="link">Source</a> <a href="#v:difference" class="selflink">#</a></p><div class="doc"><p>Difference.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) -&gt; empty `difference` a .== empty
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) -&gt; a `difference` empty .== a
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) -&gt; full `difference` a .== complement a
</code></strong>Q.E.D.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>prove $ \(a :: SSet Integer) -&gt; a `difference` a .== empty
</code></strong>Q.E.D.
</pre></div></div><div class="top"><p class="src"><a id="v:-92--92-" class="def">(\\)</a> :: (<a href="../base-4.13.0.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="Data-SBV-Internals.html#t:SymVal" title="Data.SBV.Internals">SymVal</a> a) =&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a -&gt; <a href="Data-SBV-Internals.html#t:SSet" title="Data.SBV.Internals">SSet</a> a <span class="fixity">infixl 9</span><span class="rightedge"></span> <a href="src/Data.SBV.Set.html#%5C%5C" class="link">Source</a> <a href="#v:-92--92-" class="selflink">#</a></p><div class="doc"><p>Synonym for <code><a href="Data-SBV-Set.html#v:difference" title="Data.SBV.Set">difference</a></code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>