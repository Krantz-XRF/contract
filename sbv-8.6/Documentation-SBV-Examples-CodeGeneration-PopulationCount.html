<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Documentation.SBV.Examples.CodeGeneration.PopulationCount</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">sbv-8.6: SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.</span><ul class="links" id="page-menu"><li><a href="src/Documentation.SBV.Examples.CodeGeneration.PopulationCount.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Levent Erkok</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>erkokl@gmail.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Documentation.SBV.Examples.CodeGeneration.PopulationCount</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Reference: Slow but <em>obviously</em> correct</a></li><li><a href="#g:2">Faster: Using a look-up table</a></li><li><a href="#g:3">Verification</a></li><li><a href="#g:4">Code generation</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Computing population-counts (number of set bits) and automatically
 generating C code.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:popCountSlow">popCountSlow</a> :: <a href="Data-SBV-Internals.html#t:SWord64" title="Data.SBV.Internals">SWord64</a> -&gt; <a href="Data-SBV-Internals.html#t:SWord8" title="Data.SBV.Internals">SWord8</a></li><li class="src short"><a href="#v:popCountFast">popCountFast</a> :: <a href="Data-SBV-Internals.html#t:SWord64" title="Data.SBV.Internals">SWord64</a> -&gt; <a href="Data-SBV-Internals.html#t:SWord8" title="Data.SBV.Internals">SWord8</a></li><li class="src short"><a href="#v:pop8">pop8</a> :: [<a href="Data-SBV-Internals.html#t:SWord8" title="Data.SBV.Internals">SWord8</a>]</li><li class="src short"><a href="#v:fastPopCountIsCorrect">fastPopCountIsCorrect</a> :: <a href="Data-SBV-Internals.html#t:SWord64" title="Data.SBV.Internals">SWord64</a> -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a></li><li class="src short"><a href="#v:genPopCountInC">genPopCountInC</a> :: <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Reference: Slow but <em>obviously</em> correct</h1></a><div class="top"><p class="src"><a id="v:popCountSlow" class="def">popCountSlow</a> :: <a href="Data-SBV-Internals.html#t:SWord64" title="Data.SBV.Internals">SWord64</a> -&gt; <a href="Data-SBV-Internals.html#t:SWord8" title="Data.SBV.Internals">SWord8</a> <a href="src/Documentation.SBV.Examples.CodeGeneration.PopulationCount.html#popCountSlow" class="link">Source</a> <a href="#v:popCountSlow" class="selflink">#</a></p><div class="doc"><p>Given a 64-bit quantity, the simplest (and obvious) way to count the
 number of bits that are set in it is to simply walk through all the bits
 and add 1 to a running count. This is slow, as it requires 64 iterations,
 but is simple and easy to convince yourself that it is correct. For instance:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>popCountSlow 0x0123456789ABCDEF
</code></strong>32 :: SWord8
</pre></div></div><a href="#g:2" id="g:2"><h1>Faster: Using a look-up table</h1></a><div class="top"><p class="src"><a id="v:popCountFast" class="def">popCountFast</a> :: <a href="Data-SBV-Internals.html#t:SWord64" title="Data.SBV.Internals">SWord64</a> -&gt; <a href="Data-SBV-Internals.html#t:SWord8" title="Data.SBV.Internals">SWord8</a> <a href="src/Documentation.SBV.Examples.CodeGeneration.PopulationCount.html#popCountFast" class="link">Source</a> <a href="#v:popCountFast" class="selflink">#</a></p><div class="doc"><p>Faster version. This is essentially the same algorithm, except we
 go 8 bits at a time instead of one by one, by using a precomputed table
 of population-count values for each byte. This algorithm <em>loops</em> only
 8 times, and hence is at least 8 times more efficient.</p></div></div><div class="top"><p class="src"><a id="v:pop8" class="def">pop8</a> :: [<a href="Data-SBV-Internals.html#t:SWord8" title="Data.SBV.Internals">SWord8</a>] <a href="src/Documentation.SBV.Examples.CodeGeneration.PopulationCount.html#pop8" class="link">Source</a> <a href="#v:pop8" class="selflink">#</a></p><div class="doc"><p>Look-up table, containing population counts for all possible 8-bit
 value, from 0 to 255. Note that we do not &quot;hard-code&quot; the values, but
 merely use the slow version to compute them.</p></div></div><a href="#g:3" id="g:3"><h1>Verification</h1></a><div class="doc"><p>We prove that <code><a href="Documentation-SBV-Examples-CodeGeneration-PopulationCount.html#v:popCountFast" title="Documentation.SBV.Examples.CodeGeneration.PopulationCount">popCountFast</a></code> and <code><a href="Documentation-SBV-Examples-CodeGeneration-PopulationCount.html#v:popCountSlow" title="Documentation.SBV.Examples.CodeGeneration.PopulationCount">popCountSlow</a></code> are functionally equivalent.
This is essential as we will automatically generate C code from <code><a href="Documentation-SBV-Examples-CodeGeneration-PopulationCount.html#v:popCountFast" title="Documentation.SBV.Examples.CodeGeneration.PopulationCount">popCountFast</a></code>,
and we would like to make sure that the fast version is correct with
respect to the slower reference version.</p></div><div class="top"><p class="src"><a id="v:fastPopCountIsCorrect" class="def">fastPopCountIsCorrect</a> :: <a href="Data-SBV-Internals.html#t:SWord64" title="Data.SBV.Internals">SWord64</a> -&gt; <a href="Data-SBV-Internals.html#t:SBool" title="Data.SBV.Internals">SBool</a> <a href="src/Documentation.SBV.Examples.CodeGeneration.PopulationCount.html#fastPopCountIsCorrect" class="link">Source</a> <a href="#v:fastPopCountIsCorrect" class="selflink">#</a></p><div class="doc"><p>States the correctness of faster population-count algorithm, with respect
 to the reference slow version. Turns out Z3's default solver is rather slow
 for this one, but there's a magic incantation to make it go fast.
 See <a href="http://github.com/Z3Prover/z3/issues/1150">http://github.com/Z3Prover/z3/issues/1150</a> for details.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let cmd = &quot;(check-sat-using (then (using-params ackermannize_bv :div0_ackermann_limit 1000000) simplify bit-blast sat))&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>proveWith z3{satCmd = cmd} fastPopCountIsCorrect
</code></strong>Q.E.D.
</pre></div></div><a href="#g:4" id="g:4"><h1>Code generation</h1></a><div class="top"><p class="src"><a id="v:genPopCountInC" class="def">genPopCountInC</a> :: <a href="../base-4.13.0.0/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Documentation.SBV.Examples.CodeGeneration.PopulationCount.html#genPopCountInC" class="link">Source</a> <a href="#v:genPopCountInC" class="selflink">#</a></p><div class="doc"><p>Not only we can prove that faster version is correct, but we can also automatically
 generate C code to compute population-counts for us. This action will generate all the
 C files that you will need, including a driver program for test purposes.</p><p>Below is the generated header file for <code><a href="Documentation-SBV-Examples-CodeGeneration-PopulationCount.html#v:popCountFast" title="Documentation.SBV.Examples.CodeGeneration.PopulationCount">popCountFast</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>genPopCountInC
</code></strong>== BEGIN: &quot;Makefile&quot; ================
# Makefile for popCount. Automatically generated by SBV. Do not edit!

# include any user-defined .mk file in the current directory.
-include *.mk

CC?=gcc
CCFLAGS?=-Wall -O3 -DNDEBUG -fomit-frame-pointer

all: popCount_driver

popCount.o: popCount.c popCount.h
	${CC} ${CCFLAGS} -c $&lt; -o $@

popCount_driver.o: popCount_driver.c
	${CC} ${CCFLAGS} -c $&lt; -o $@

popCount_driver: popCount.o popCount_driver.o
	${CC} ${CCFLAGS} $^ -o $@

clean:
	rm -f *.o

veryclean: clean
	rm -f popCount_driver
== END: &quot;Makefile&quot; ==================
== BEGIN: &quot;popCount.h&quot; ================
/* Header file for popCount. Automatically generated by SBV. Do not edit! */

#ifndef __popCount__HEADER_INCLUDED__
#define __popCount__HEADER_INCLUDED__

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;

/* The boolean type */
typedef bool SBool;

/* The float type */
typedef float SFloat;

/* The double type */
typedef double SDouble;

/* Unsigned bit-vectors */
typedef uint8_t  SWord8;
typedef uint16_t SWord16;
typedef uint32_t SWord32;
typedef uint64_t SWord64;

/* Signed bit-vectors */
typedef int8_t  SInt8;
typedef int16_t SInt16;
typedef int32_t SInt32;
typedef int64_t SInt64;

/* Entry point prototype: */
SWord8 popCount(const SWord64 x);

#endif /* __popCount__HEADER_INCLUDED__ */
== END: &quot;popCount.h&quot; ==================
== BEGIN: &quot;popCount_driver.c&quot; ================
/* Example driver program for popCount. */
/* Automatically generated by SBV. Edit as you see fit! */

#include &lt;stdio.h&gt;
#include &quot;popCount.h&quot;

int main(void)
{
  const SWord8 __result = popCount(0x1b02e143e4f0e0e5ULL);

  printf(&quot;popCount(0x1b02e143e4f0e0e5ULL) = %&quot;PRIu8&quot;\n&quot;, __result);

  return 0;
}
== END: &quot;popCount_driver.c&quot; ==================
== BEGIN: &quot;popCount.c&quot; ================
/* File: &quot;popCount.c&quot;. Automatically generated by SBV. Do not edit! */

#include &quot;popCount.h&quot;

SWord8 popCount(const SWord64 x)
{
  const SWord64 s0 = x;
  static const SWord8 table0[] = {
      0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3,
      3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4,
      3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2,
      2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5,
      3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5,
      5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3,
      2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4,
      4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4,
      4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6,
      5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5,
      5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
  };
  const SWord64 s11 = s0 &amp; 0x00000000000000ffULL;
  const SWord8  s12 = table0[s11];
  const SWord64 s14 = s0 &gt;&gt; 8;
  const SWord64 s15 = 0x00000000000000ffULL &amp; s14;
  const SWord8  s16 = table0[s15];
  const SWord8  s17 = s12 + s16;
  const SWord64 s18 = s14 &gt;&gt; 8;
  const SWord64 s19 = 0x00000000000000ffULL &amp; s18;
  const SWord8  s20 = table0[s19];
  const SWord8  s21 = s17 + s20;
  const SWord64 s22 = s18 &gt;&gt; 8;
  const SWord64 s23 = 0x00000000000000ffULL &amp; s22;
  const SWord8  s24 = table0[s23];
  const SWord8  s25 = s21 + s24;
  const SWord64 s26 = s22 &gt;&gt; 8;
  const SWord64 s27 = 0x00000000000000ffULL &amp; s26;
  const SWord8  s28 = table0[s27];
  const SWord8  s29 = s25 + s28;
  const SWord64 s30 = s26 &gt;&gt; 8;
  const SWord64 s31 = 0x00000000000000ffULL &amp; s30;
  const SWord8  s32 = table0[s31];
  const SWord8  s33 = s29 + s32;
  const SWord64 s34 = s30 &gt;&gt; 8;
  const SWord64 s35 = 0x00000000000000ffULL &amp; s34;
  const SWord8  s36 = table0[s35];
  const SWord8  s37 = s33 + s36;
  const SWord64 s38 = s34 &gt;&gt; 8;
  const SWord64 s39 = 0x00000000000000ffULL &amp; s38;
  const SWord8  s40 = table0[s39];
  const SWord8  s41 = s37 + s40;

  return s41;
}
== END: &quot;popCount.c&quot; ==================
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>