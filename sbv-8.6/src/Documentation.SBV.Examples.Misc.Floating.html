<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-2"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- Module    : Documentation.SBV.Examples.Misc.Floating</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- Copyright : (c) Levent Erkok</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- License   : BSD3</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- Maintainer: erkokl@gmail.com</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- Stability : experimental</span><span>
</span><span id="line-8"></span><span class="hs-comment">--</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- Several examples involving IEEE-754 floating point numbers, i.e., single</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- precision 'Float' ('SFloat') and double precision 'Double' ('SDouble') types.</span><span>
</span><span id="line-11"></span><span class="hs-comment">--</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- Note that arithmetic with floating point is full of surprises; due to precision</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- issues associativity of arithmetic operations typically do not hold. Also,</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- the presence of @NaN@ is always something to look out for.</span><span>
</span><span id="line-15"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-16"></span><span>
</span><span id="line-17"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-18"></span><span>
</span><span id="line-19"></span><span class="hs-pragma">{-# OPTIONS_GHC -Wall -Werror #-}</span><span>
</span><span id="line-20"></span><span>
</span><span id="line-21"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Documentation.SBV.Examples.Misc.Floating</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-22"></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.SBV.html"><span class="hs-identifier">Data.SBV</span></a></span><span>
</span><span id="line-24"></span><span>
</span><span id="line-25"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- * FP addition is not associative</span><span>
</span><span id="line-27"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-28"></span><span>
</span><span id="line-29"></span><span class="hs-comment">-- | Prove that floating point addition is not associative. For illustration purposes,</span><span>
</span><span id="line-30"></span><span class="hs-comment">-- we will require one of the inputs to be a @NaN@. We have:</span><span>
</span><span id="line-31"></span><span class="hs-comment">--</span><span>
</span><span id="line-32"></span><span class="hs-comment">-- &gt;&gt;&gt; prove $ assocPlus (0/0)</span><span>
</span><span id="line-33"></span><span class="hs-comment">-- Falsifiable. Counter-example:</span><span>
</span><span id="line-34"></span><span class="hs-comment">--   s0 = 0.0 :: Float</span><span>
</span><span id="line-35"></span><span class="hs-comment">--   s1 = 0.0 :: Float</span><span>
</span><span id="line-36"></span><span class="hs-comment">--</span><span>
</span><span id="line-37"></span><span class="hs-comment">-- Indeed:</span><span>
</span><span id="line-38"></span><span class="hs-comment">--</span><span>
</span><span id="line-39"></span><span class="hs-comment">-- &gt;&gt;&gt; let i = 0/0 :: Float</span><span>
</span><span id="line-40"></span><span class="hs-comment">-- &gt;&gt;&gt; i + (0.0 + 0.0)</span><span>
</span><span id="line-41"></span><span class="hs-comment">-- NaN</span><span>
</span><span id="line-42"></span><span class="hs-comment">-- &gt;&gt;&gt; ((i + 0.0) + 0.0)</span><span>
</span><span id="line-43"></span><span class="hs-comment">-- NaN</span><span>
</span><span id="line-44"></span><span class="hs-comment">--</span><span>
</span><span id="line-45"></span><span class="hs-comment">-- But keep in mind that @NaN@ does not equal itself in the floating point world! We have:</span><span>
</span><span id="line-46"></span><span class="hs-comment">--</span><span>
</span><span id="line-47"></span><span class="hs-comment">-- &gt;&gt;&gt; let nan = 0/0 :: Float in nan == nan</span><span>
</span><span id="line-48"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-49"></span><span class="annot"><a href="Documentation.SBV.Examples.Misc.Floating.html#assocPlus"><span class="hs-identifier hs-type">assocPlus</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SFloat"><span class="hs-identifier hs-type">SFloat</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SFloat"><span class="hs-identifier hs-type">SFloat</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SFloat"><span class="hs-identifier hs-type">SFloat</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBool"><span class="hs-identifier hs-type">SBool</span></a></span><span>
</span><span id="line-50"></span><span id="assocPlus"><span class="annot"><span class="annottext">assocPlus :: SFloat -&gt; SFloat -&gt; SFloat -&gt; SBool
</span><a href="Documentation.SBV.Examples.Misc.Floating.html#assocPlus"><span class="hs-identifier hs-var hs-var">assocPlus</span></a></span></span><span> </span><span id="local-6989586621681162540"><span class="annot"><span class="annottext">x :: SFloat
</span><a href="#local-6989586621681162540"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621681162539"><span class="annot"><span class="annottext">y :: SFloat
</span><a href="#local-6989586621681162539"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span id="local-6989586621681162538"><span class="annot"><span class="annottext">z :: SFloat
</span><a href="#local-6989586621681162538"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162540"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SFloat
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162539"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SFloat
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162538"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SBool
forall a. EqSymbolic a =&gt; a -&gt; a -&gt; SBool
</span><a href="Data.SBV.Core.Model.html#.%3D%3D"><span class="hs-operator hs-var">.==</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162540"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SFloat
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162539"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SFloat
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162538"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span class="hs-comment">-- | Prove that addition is not associative, even if we ignore @NaN@/@Infinity@ values.</span><span>
</span><span id="line-53"></span><span class="hs-comment">-- To do this, we use the predicate 'fpIsPoint', which is true of a floating point</span><span>
</span><span id="line-54"></span><span class="hs-comment">-- number ('SFloat' or 'SDouble') if it is neither @NaN@ nor @Infinity@. (That is, it's a</span><span>
</span><span id="line-55"></span><span class="hs-comment">-- representable point in the real-number line.)</span><span>
</span><span id="line-56"></span><span class="hs-comment">--</span><span>
</span><span id="line-57"></span><span class="hs-comment">-- We have:</span><span>
</span><span id="line-58"></span><span class="hs-comment">--</span><span>
</span><span id="line-59"></span><span class="hs-comment">-- &gt;&gt;&gt; assocPlusRegular</span><span>
</span><span id="line-60"></span><span class="hs-comment">-- Falsifiable. Counter-example:</span><span>
</span><span id="line-61"></span><span class="hs-comment">--   x =   5.615828e-4 :: Float</span><span>
</span><span id="line-62"></span><span class="hs-comment">--   y = -2.2688436e-3 :: Float</span><span>
</span><span id="line-63"></span><span class="hs-comment">--   z =    -2047.9991 :: Float</span><span>
</span><span id="line-64"></span><span class="hs-comment">--</span><span>
</span><span id="line-65"></span><span class="hs-comment">-- Indeed, we have:</span><span>
</span><span id="line-66"></span><span class="hs-comment">--</span><span>
</span><span id="line-67"></span><span class="hs-comment">-- &gt;&gt;&gt; let x =   5.615828e-4 :: Float</span><span>
</span><span id="line-68"></span><span class="hs-comment">-- &gt;&gt;&gt; let y = -2.2688436e-3 :: Float</span><span>
</span><span id="line-69"></span><span class="hs-comment">-- &gt;&gt;&gt; let z =    -2047.9991 :: Float</span><span>
</span><span id="line-70"></span><span class="hs-comment">-- &gt;&gt;&gt; x + (y + z)</span><span>
</span><span id="line-71"></span><span class="hs-comment">-- -2048.001</span><span>
</span><span id="line-72"></span><span class="hs-comment">-- &gt;&gt;&gt; (x + y) + z</span><span>
</span><span id="line-73"></span><span class="hs-comment">-- -2048.0007</span><span>
</span><span id="line-74"></span><span class="hs-comment">--</span><span>
</span><span id="line-75"></span><span class="hs-comment">-- Note the difference in the results!</span><span>
</span><span id="line-76"></span><span class="annot"><a href="Documentation.SBV.Examples.Misc.Floating.html#assocPlusRegular"><span class="hs-identifier hs-type">assocPlusRegular</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#ThmResult"><span class="hs-identifier hs-type">ThmResult</span></a></span><span>
</span><span id="line-77"></span><span id="assocPlusRegular"><span class="annot"><span class="annottext">assocPlusRegular :: IO ThmResult
</span><a href="Documentation.SBV.Examples.Misc.Floating.html#assocPlusRegular"><span class="hs-identifier hs-var hs-var">assocPlusRegular</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SymbolicT IO SBool -&gt; IO ThmResult
forall a. Provable a =&gt; a -&gt; IO ThmResult
</span><a href="Data.SBV.Client.BaseIO.html#prove"><span class="hs-identifier hs-var">prove</span></a></span><span> </span><span class="annot"><span class="annottext">(SymbolicT IO SBool -&gt; IO ThmResult)
-&gt; SymbolicT IO SBool -&gt; IO ThmResult
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">[</span><span id="local-6989586621681162533"><span class="annot"><span class="annottext">x :: SFloat
</span><a href="#local-6989586621681162533"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681162532"><span class="annot"><span class="annottext">y :: SFloat
</span><a href="#local-6989586621681162532"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681162531"><span class="annot"><span class="annottext">z :: SFloat
</span><a href="#local-6989586621681162531"><span class="hs-identifier hs-var">z</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SFloat]
</span><a href="Data.SBV.Client.BaseIO.html#sFloats"><span class="hs-identifier hs-var">sFloats</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;x&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;y&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;z&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-78"></span><span>                              </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681162529"><span class="annot"><span class="annottext">lhs :: SFloat
</span><a href="#local-6989586621681162529"><span class="hs-identifier hs-var hs-var">lhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162533"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SFloat
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span class="hs-special">(</span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162532"><span class="hs-identifier hs-var">y</span></a></span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SFloat
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162531"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-79"></span><span>                                  </span><span id="local-6989586621681162528"><span class="annot"><span class="annottext">rhs :: SFloat
</span><a href="#local-6989586621681162528"><span class="hs-identifier hs-var hs-var">rhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162533"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SFloat
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162532"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SFloat
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162531"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-80"></span><span>                              </span><span class="hs-comment">-- make sure we do not overflow at the intermediate points</span><span>
</span><span id="line-81"></span><span>                              </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO ()
forall (m :: * -&gt; *). SolverContext m =&gt; SBool -&gt; m ()
</span><a href="Data.SBV.Core.Data.html#constrain"><span class="hs-identifier hs-var">constrain</span></a></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO ()) -&gt; SBool -&gt; SymbolicT IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SBool
forall a. IEEEFloating a =&gt; SBV a -&gt; SBool
</span><a href="Data.SBV.Core.Floating.html#fpIsPoint"><span class="hs-identifier hs-var">fpIsPoint</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162529"><span class="hs-identifier hs-var">lhs</span></a></span><span>
</span><span id="line-82"></span><span>                              </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO ()
forall (m :: * -&gt; *). SolverContext m =&gt; SBool -&gt; m ()
</span><a href="Data.SBV.Core.Data.html#constrain"><span class="hs-identifier hs-var">constrain</span></a></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO ()) -&gt; SBool -&gt; SymbolicT IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SBool
forall a. IEEEFloating a =&gt; SBV a -&gt; SBool
</span><a href="Data.SBV.Core.Floating.html#fpIsPoint"><span class="hs-identifier hs-var">fpIsPoint</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162528"><span class="hs-identifier hs-var">rhs</span></a></span><span>
</span><span id="line-83"></span><span>                              </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO SBool
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO SBool) -&gt; SBool -&gt; SymbolicT IO SBool
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162529"><span class="hs-identifier hs-var">lhs</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SBool
forall a. EqSymbolic a =&gt; a -&gt; a -&gt; SBool
</span><a href="Data.SBV.Core.Model.html#.%3D%3D"><span class="hs-operator hs-var">.==</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162528"><span class="hs-identifier hs-var">rhs</span></a></span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-86"></span><span class="hs-comment">-- * FP addition by non-zero can result in no change</span><span>
</span><span id="line-87"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span class="hs-comment">-- | Demonstrate that @a+b = a@ does not necessarily mean @b@ is @0@ in the floating point world,</span><span>
</span><span id="line-90"></span><span class="hs-comment">-- even when we disallow the obvious solution when @a@ and @b@ are @Infinity.@</span><span>
</span><span id="line-91"></span><span class="hs-comment">-- We have:</span><span>
</span><span id="line-92"></span><span class="hs-comment">--</span><span>
</span><span id="line-93"></span><span class="hs-comment">-- &gt;&gt;&gt; nonZeroAddition</span><span>
</span><span id="line-94"></span><span class="hs-comment">-- Falsifiable. Counter-example:</span><span>
</span><span id="line-95"></span><span class="hs-comment">--   a =   -1.9999999 :: Float</span><span>
</span><span id="line-96"></span><span class="hs-comment">--   b = 9.403954e-38 :: Float</span><span>
</span><span id="line-97"></span><span class="hs-comment">--</span><span>
</span><span id="line-98"></span><span class="hs-comment">-- Indeed, we have:</span><span>
</span><span id="line-99"></span><span class="hs-comment">--</span><span>
</span><span id="line-100"></span><span class="hs-comment">-- &gt;&gt;&gt; let a =   -1.9999999 :: Float</span><span>
</span><span id="line-101"></span><span class="hs-comment">-- &gt;&gt;&gt; let b = 9.403954e-38 :: Float</span><span>
</span><span id="line-102"></span><span class="hs-comment">-- &gt;&gt;&gt; a + b == a</span><span>
</span><span id="line-103"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-104"></span><span class="hs-comment">-- &gt;&gt;&gt; b == 0</span><span>
</span><span id="line-105"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-106"></span><span class="annot"><a href="Documentation.SBV.Examples.Misc.Floating.html#nonZeroAddition"><span class="hs-identifier hs-type">nonZeroAddition</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#ThmResult"><span class="hs-identifier hs-type">ThmResult</span></a></span><span>
</span><span id="line-107"></span><span id="nonZeroAddition"><span class="annot"><span class="annottext">nonZeroAddition :: IO ThmResult
</span><a href="Documentation.SBV.Examples.Misc.Floating.html#nonZeroAddition"><span class="hs-identifier hs-var hs-var">nonZeroAddition</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SymbolicT IO SBool -&gt; IO ThmResult
forall a. Provable a =&gt; a -&gt; IO ThmResult
</span><a href="Data.SBV.Client.BaseIO.html#prove"><span class="hs-identifier hs-var">prove</span></a></span><span> </span><span class="annot"><span class="annottext">(SymbolicT IO SBool -&gt; IO ThmResult)
-&gt; SymbolicT IO SBool -&gt; IO ThmResult
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">[</span><span id="local-6989586621681162524"><span class="annot"><span class="annottext">a :: SFloat
</span><a href="#local-6989586621681162524"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681162523"><span class="annot"><span class="annottext">b :: SFloat
</span><a href="#local-6989586621681162523"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SFloat]
</span><a href="Data.SBV.Client.BaseIO.html#sFloats"><span class="hs-identifier hs-var">sFloats</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;b&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-108"></span><span>                             </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO ()
forall (m :: * -&gt; *). SolverContext m =&gt; SBool -&gt; m ()
</span><a href="Data.SBV.Core.Data.html#constrain"><span class="hs-identifier hs-var">constrain</span></a></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO ()) -&gt; SBool -&gt; SymbolicT IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SBool
forall a. IEEEFloating a =&gt; SBV a -&gt; SBool
</span><a href="Data.SBV.Core.Floating.html#fpIsPoint"><span class="hs-identifier hs-var">fpIsPoint</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162524"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-109"></span><span>                             </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO ()
forall (m :: * -&gt; *). SolverContext m =&gt; SBool -&gt; m ()
</span><a href="Data.SBV.Core.Data.html#constrain"><span class="hs-identifier hs-var">constrain</span></a></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO ()) -&gt; SBool -&gt; SymbolicT IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SBool
forall a. IEEEFloating a =&gt; SBV a -&gt; SBool
</span><a href="Data.SBV.Core.Floating.html#fpIsPoint"><span class="hs-identifier hs-var">fpIsPoint</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162523"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-110"></span><span>                             </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO ()
forall (m :: * -&gt; *). SolverContext m =&gt; SBool -&gt; m ()
</span><a href="Data.SBV.Core.Data.html#constrain"><span class="hs-identifier hs-var">constrain</span></a></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO ()) -&gt; SBool -&gt; SymbolicT IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162524"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SFloat
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162523"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SBool
forall a. EqSymbolic a =&gt; a -&gt; a -&gt; SBool
</span><a href="Data.SBV.Core.Model.html#.%3D%3D"><span class="hs-operator hs-var">.==</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162524"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-111"></span><span>                             </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO SBool
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO SBool) -&gt; SBool -&gt; SymbolicT IO SBool
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162523"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SBool
forall a. EqSymbolic a =&gt; a -&gt; a -&gt; SBool
</span><a href="Data.SBV.Core.Model.html#.%3D%3D"><span class="hs-operator hs-var">.==</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span>
</span><span id="line-112"></span><span>
</span><span id="line-113"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-114"></span><span class="hs-comment">-- * FP multiplicative inverses may not exist</span><span>
</span><span id="line-115"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-116"></span><span>
</span><span id="line-117"></span><span class="hs-comment">-- | This example illustrates that @a * (1/a)@ does not necessarily equal @1@. Again,</span><span>
</span><span id="line-118"></span><span class="hs-comment">-- we protect against division by @0@ and @NaN@/@Infinity@.</span><span>
</span><span id="line-119"></span><span class="hs-comment">--</span><span>
</span><span id="line-120"></span><span class="hs-comment">-- We have:</span><span>
</span><span id="line-121"></span><span class="hs-comment">--</span><span>
</span><span id="line-122"></span><span class="hs-comment">-- &gt;&gt;&gt; multInverse</span><span>
</span><span id="line-123"></span><span class="hs-comment">-- Falsifiable. Counter-example:</span><span>
</span><span id="line-124"></span><span class="hs-comment">--   a = -1.910829855912238e-308 :: Double</span><span>
</span><span id="line-125"></span><span class="hs-comment">--</span><span>
</span><span id="line-126"></span><span class="hs-comment">-- Indeed, we have:</span><span>
</span><span id="line-127"></span><span class="hs-comment">--</span><span>
</span><span id="line-128"></span><span class="hs-comment">-- &gt;&gt;&gt; let a = -1.910829855912238e-308 :: Double</span><span>
</span><span id="line-129"></span><span class="hs-comment">-- &gt;&gt;&gt; a * (1/a)</span><span>
</span><span id="line-130"></span><span class="hs-comment">-- 0.9999999999999999</span><span>
</span><span id="line-131"></span><span class="annot"><a href="Documentation.SBV.Examples.Misc.Floating.html#multInverse"><span class="hs-identifier hs-type">multInverse</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#ThmResult"><span class="hs-identifier hs-type">ThmResult</span></a></span><span>
</span><span id="line-132"></span><span id="multInverse"><span class="annot"><span class="annottext">multInverse :: IO ThmResult
</span><a href="Documentation.SBV.Examples.Misc.Floating.html#multInverse"><span class="hs-identifier hs-var hs-var">multInverse</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SymbolicT IO SBool -&gt; IO ThmResult
forall a. Provable a =&gt; a -&gt; IO ThmResult
</span><a href="Data.SBV.Client.BaseIO.html#prove"><span class="hs-identifier hs-var">prove</span></a></span><span> </span><span class="annot"><span class="annottext">(SymbolicT IO SBool -&gt; IO ThmResult)
-&gt; SymbolicT IO SBool -&gt; IO ThmResult
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621681162521"><span class="annot"><span class="annottext">SDouble
</span><a href="#local-6989586621681162521"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SDouble
</span><a href="Data.SBV.Client.BaseIO.html#sDouble"><span class="hs-identifier hs-var">sDouble</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;a&quot;</span></span><span>
</span><span id="line-133"></span><span>                         </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO ()
forall (m :: * -&gt; *). SolverContext m =&gt; SBool -&gt; m ()
</span><a href="Data.SBV.Core.Data.html#constrain"><span class="hs-identifier hs-var">constrain</span></a></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO ()) -&gt; SBool -&gt; SymbolicT IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SDouble -&gt; SBool
forall a. IEEEFloating a =&gt; SBV a -&gt; SBool
</span><a href="Data.SBV.Core.Floating.html#fpIsPoint"><span class="hs-identifier hs-var">fpIsPoint</span></a></span><span> </span><span class="annot"><span class="annottext">SDouble
</span><a href="#local-6989586621681162521"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-134"></span><span>                         </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO ()
forall (m :: * -&gt; *). SolverContext m =&gt; SBool -&gt; m ()
</span><a href="Data.SBV.Core.Data.html#constrain"><span class="hs-identifier hs-var">constrain</span></a></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO ()) -&gt; SBool -&gt; SymbolicT IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SDouble -&gt; SBool
forall a. IEEEFloating a =&gt; SBV a -&gt; SBool
</span><a href="Data.SBV.Core.Floating.html#fpIsPoint"><span class="hs-identifier hs-var">fpIsPoint</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-number">1</span></span><span class="annot"><span class="annottext">SDouble -&gt; SDouble -&gt; SDouble
forall a. Fractional a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">/</span></span><span class="annot"><span class="annottext">SDouble
</span><a href="#local-6989586621681162521"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-135"></span><span>                         </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO SBool
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO SBool) -&gt; SBool -&gt; SymbolicT IO SBool
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SDouble
</span><a href="#local-6989586621681162521"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">SDouble -&gt; SDouble -&gt; SDouble
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">*</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-number">1</span></span><span class="annot"><span class="annottext">SDouble -&gt; SDouble -&gt; SDouble
forall a. Fractional a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">/</span></span><span class="annot"><span class="annottext">SDouble
</span><a href="#local-6989586621681162521"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">SDouble -&gt; SDouble -&gt; SBool
forall a. EqSymbolic a =&gt; a -&gt; a -&gt; SBool
</span><a href="Data.SBV.Core.Model.html#.%3D%3D"><span class="hs-operator hs-var">.==</span></a></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span>
</span><span id="line-136"></span><span>
</span><span id="line-137"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-138"></span><span class="hs-comment">-- * Effect of rounding modes</span><span>
</span><span id="line-139"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-140"></span><span>
</span><span id="line-141"></span><span class="hs-comment">-- | One interesting aspect of floating-point is that the chosen rounding-mode</span><span>
</span><span id="line-142"></span><span class="hs-comment">-- can effect the results of a computation if the exact result cannot be precisely</span><span>
</span><span id="line-143"></span><span class="hs-comment">-- represented. SBV exports the functions 'fpAdd', 'fpSub', 'fpMul', 'fpDiv', 'fpFMA'</span><span>
</span><span id="line-144"></span><span class="hs-comment">-- and 'fpSqrt' which allows users to specify the IEEE supported 'RoundingMode' for</span><span>
</span><span id="line-145"></span><span class="hs-comment">-- the operation. This example illustrates how SBV can be used to find rounding-modes</span><span>
</span><span id="line-146"></span><span class="hs-comment">-- where, for instance, addition can produce different results. We have:</span><span>
</span><span id="line-147"></span><span class="hs-comment">--</span><span>
</span><span id="line-148"></span><span class="hs-comment">-- &gt;&gt;&gt; roundingAdd</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- Satisfiable. Model:</span><span>
</span><span id="line-150"></span><span class="hs-comment">--   rm = RoundNearestTiesToAway :: RoundingMode</span><span>
</span><span id="line-151"></span><span class="hs-comment">--   x  =                    1.0 :: Float</span><span>
</span><span id="line-152"></span><span class="hs-comment">--   y  =            -0.43749997 :: Float</span><span>
</span><span id="line-153"></span><span class="hs-comment">--</span><span>
</span><span id="line-154"></span><span class="hs-comment">-- (Note that depending on your version of Z3, you might get a different result.)</span><span>
</span><span id="line-155"></span><span class="hs-comment">-- Unfortunately we can't directly validate this result at the Haskell level, as Haskell only supports</span><span>
</span><span id="line-156"></span><span class="hs-comment">-- 'RoundNearestTiesToEven'. We have:</span><span>
</span><span id="line-157"></span><span class="hs-comment">--</span><span>
</span><span id="line-158"></span><span class="hs-comment">-- &gt;&gt;&gt; 1.0 + (-0.43749997) :: Float</span><span>
</span><span id="line-159"></span><span class="hs-comment">-- 0.5625</span><span>
</span><span id="line-160"></span><span class="hs-comment">--</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- While we cannot directly see the result when the mode is 'RoundNearestTiesToAway' in Haskell, we can use</span><span>
</span><span id="line-162"></span><span class="hs-comment">-- SBV to provide us with that result thusly:</span><span>
</span><span id="line-163"></span><span class="hs-comment">--</span><span>
</span><span id="line-164"></span><span class="hs-comment">-- &gt;&gt;&gt; sat $ \z -&gt; z .== fpAdd sRoundNearestTiesToAway 1.0 (-0.43749997 :: SFloat)</span><span>
</span><span id="line-165"></span><span class="hs-comment">-- Satisfiable. Model:</span><span>
</span><span id="line-166"></span><span class="hs-comment">--   s0 = 0.56250006 :: Float</span><span>
</span><span id="line-167"></span><span class="hs-comment">--</span><span>
</span><span id="line-168"></span><span class="hs-comment">-- We can see why these two resuls are indeed different: The 'RoundNearestTiesToAway'</span><span>
</span><span id="line-169"></span><span class="hs-comment">-- (which rounds away from zero) produces a larger result. Indeed, if we treat these numbers</span><span>
</span><span id="line-170"></span><span class="hs-comment">-- as 'Double' values, we get:</span><span>
</span><span id="line-171"></span><span class="hs-comment">--</span><span>
</span><span id="line-172"></span><span class="hs-comment">-- &gt;&gt; 1.0 + (-0.43749997 :: Double)</span><span>
</span><span id="line-173"></span><span class="hs-comment">-- 0.56250003</span><span>
</span><span id="line-174"></span><span class="hs-comment">--</span><span>
</span><span id="line-175"></span><span class="hs-comment">-- we see that the &quot;more precise&quot; result is larger than what the 'Float' value is, justifying the</span><span>
</span><span id="line-176"></span><span class="hs-comment">-- larger value with 'RoundNearestTiesToAway'. A more detailed study is beyond our current scope, so we'll</span><span>
</span><span id="line-177"></span><span class="hs-comment">-- merely note that floating point representation and semantics is indeed a thorny</span><span>
</span><span id="line-178"></span><span class="hs-comment">-- subject, and point to &lt;http://ece.uwaterloo.ca/~dwharder/NumericalAnalysis/02Numerics/Double/paper.pdf&gt; as</span><span>
</span><span id="line-179"></span><span class="hs-comment">-- an excellent guide.</span><span>
</span><span id="line-180"></span><span class="annot"><a href="Documentation.SBV.Examples.Misc.Floating.html#roundingAdd"><span class="hs-identifier hs-type">roundingAdd</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#SatResult"><span class="hs-identifier hs-type">SatResult</span></a></span><span>
</span><span id="line-181"></span><span id="roundingAdd"><span class="annot"><span class="annottext">roundingAdd :: IO SatResult
</span><a href="Documentation.SBV.Examples.Misc.Floating.html#roundingAdd"><span class="hs-identifier hs-var hs-var">roundingAdd</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SymbolicT IO SBool -&gt; IO SatResult
forall a. Provable a =&gt; a -&gt; IO SatResult
</span><a href="Data.SBV.Client.BaseIO.html#sat"><span class="hs-identifier hs-var">sat</span></a></span><span> </span><span class="annot"><span class="annottext">(SymbolicT IO SBool -&gt; IO SatResult)
-&gt; SymbolicT IO SBool -&gt; IO SatResult
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621681162515"><span class="annot"><span class="annottext">SRoundingMode
</span><a href="#local-6989586621681162515"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SRoundingMode"><span class="hs-identifier hs-type">SRoundingMode</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SRoundingMode
forall a. SymVal a =&gt; String -&gt; Symbolic (SBV a)
</span><a href="Data.SBV.Client.BaseIO.html#free"><span class="hs-identifier hs-var">free</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;rm&quot;</span></span><span>
</span><span id="line-182"></span><span>                       </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO ()
forall (m :: * -&gt; *). SolverContext m =&gt; SBool -&gt; m ()
</span><a href="Data.SBV.Core.Data.html#constrain"><span class="hs-identifier hs-var">constrain</span></a></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO ()) -&gt; SBool -&gt; SymbolicT IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SRoundingMode
</span><a href="#local-6989586621681162515"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">SRoundingMode -&gt; SRoundingMode -&gt; SBool
forall a. EqSymbolic a =&gt; a -&gt; a -&gt; SBool
</span><a href="Data.SBV.Core.Model.html#.%2F%3D"><span class="hs-operator hs-var">./=</span></a></span><span> </span><span class="annot"><span class="annottext">RoundingMode -&gt; SRoundingMode
forall a. SymVal a =&gt; a -&gt; SBV a
</span><a href="Data.SBV.Core.Data.html#literal"><span class="hs-identifier hs-var">literal</span></a></span><span> </span><span class="annot"><span class="annottext">RoundingMode
</span><a href="Data.SBV.Core.Symbolic.html#RoundNearestTiesToEven"><span class="hs-identifier hs-var">RoundNearestTiesToEven</span></a></span><span>
</span><span id="line-183"></span><span>                       </span><span id="local-6989586621681162510"><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162510"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SFloat
</span><a href="Data.SBV.Client.BaseIO.html#sFloat"><span class="hs-identifier hs-var">sFloat</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;x&quot;</span></span><span>
</span><span id="line-184"></span><span>                       </span><span id="local-6989586621681162508"><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162508"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SFloat
</span><a href="Data.SBV.Client.BaseIO.html#sFloat"><span class="hs-identifier hs-var">sFloat</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;y&quot;</span></span><span>
</span><span id="line-185"></span><span>                       </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681162507"><span class="annot"><span class="annottext">lhs :: SFloat
</span><a href="#local-6989586621681162507"><span class="hs-identifier hs-var hs-var">lhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SRoundingMode -&gt; SFloat -&gt; SFloat -&gt; SFloat
forall a.
IEEEFloating a =&gt;
SRoundingMode -&gt; SBV a -&gt; SBV a -&gt; SBV a
</span><a href="Data.SBV.Core.Floating.html#fpAdd"><span class="hs-identifier hs-var">fpAdd</span></a></span><span> </span><span class="annot"><span class="annottext">SRoundingMode
</span><a href="#local-6989586621681162515"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162510"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162508"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-186"></span><span>                       </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681162505"><span class="annot"><span class="annottext">rhs :: SFloat
</span><a href="#local-6989586621681162505"><span class="hs-identifier hs-var hs-var">rhs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162510"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SFloat
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162508"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-187"></span><span>                       </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO ()
forall (m :: * -&gt; *). SolverContext m =&gt; SBool -&gt; m ()
</span><a href="Data.SBV.Core.Data.html#constrain"><span class="hs-identifier hs-var">constrain</span></a></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO ()) -&gt; SBool -&gt; SymbolicT IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SBool
forall a. IEEEFloating a =&gt; SBV a -&gt; SBool
</span><a href="Data.SBV.Core.Floating.html#fpIsPoint"><span class="hs-identifier hs-var">fpIsPoint</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162507"><span class="hs-identifier hs-var">lhs</span></a></span><span>
</span><span id="line-188"></span><span>                       </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO ()
forall (m :: * -&gt; *). SolverContext m =&gt; SBool -&gt; m ()
</span><a href="Data.SBV.Core.Data.html#constrain"><span class="hs-identifier hs-var">constrain</span></a></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO ()) -&gt; SBool -&gt; SymbolicT IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SBool
forall a. IEEEFloating a =&gt; SBV a -&gt; SBool
</span><a href="Data.SBV.Core.Floating.html#fpIsPoint"><span class="hs-identifier hs-var">fpIsPoint</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162505"><span class="hs-identifier hs-var">rhs</span></a></span><span>
</span><span id="line-189"></span><span>                       </span><span class="annot"><span class="annottext">SBool -&gt; SymbolicT IO SBool
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(SBool -&gt; SymbolicT IO SBool) -&gt; SBool -&gt; SymbolicT IO SBool
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162507"><span class="hs-identifier hs-var">lhs</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat -&gt; SFloat -&gt; SBool
forall a. EqSymbolic a =&gt; a -&gt; a -&gt; SBool
</span><a href="Data.SBV.Core.Model.html#.%2F%3D"><span class="hs-operator hs-var">./=</span></a></span><span> </span><span class="annot"><span class="annottext">SFloat
</span><a href="#local-6989586621681162505"><span class="hs-identifier hs-var">rhs</span></a></span><span>
</span><span id="line-190"></span></pre></body></html>