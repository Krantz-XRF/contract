<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-2"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- Module    : Data.SBV.Client.BaseIO</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- Copyright : (c) Brian Schroeder</span><span>
</span><span id="line-5"></span><span class="hs-comment">--                 Levent Erkok</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- License   : BSD3</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- Maintainer: erkokl@gmail.com</span><span>
</span><span id="line-8"></span><span class="hs-comment">-- Stability : experimental</span><span>
</span><span id="line-9"></span><span class="hs-comment">--</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- Monomorphized versions of functions for simplified client use via</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- @Data.SBV@, where we restrict the underlying monad to be IO.</span><span>
</span><span id="line-12"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span class="hs-pragma">{-# LANGUAGE DataKinds            #-}</span><span>
</span><span id="line-15"></span><span class="hs-pragma">{-# LANGUAGE DefaultSignatures    #-}</span><span>
</span><span id="line-16"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts     #-}</span><span>
</span><span id="line-17"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances    #-}</span><span>
</span><span id="line-18"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies         #-}</span><span>
</span><span id="line-19"></span><span class="hs-pragma">{-# LANGUAGE TypeOperators        #-}</span><span>
</span><span id="line-20"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span>
</span><span id="line-21"></span><span>
</span><span id="line-22"></span><span class="hs-pragma">{-# OPTIONS_GHC -Wall -Werror #-}</span><span>
</span><span id="line-23"></span><span>
</span><span id="line-24"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data.SBV.Client.BaseIO</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-25"></span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html"><span class="hs-identifier">Data.SBV.Core.Data</span></a></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Kind.html#HasKind"><span class="hs-identifier">HasKind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Kind.html#Kind"><span class="hs-identifier">Kind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#Outputtable"><span class="hs-identifier">Outputtable</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Penalty"><span class="hs-identifier">Penalty</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymArray"><span class="hs-identifier">SymArray</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>                                </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier">SymVal</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBool"><span class="hs-identifier">SBool</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier">SBV</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SChar"><span class="hs-identifier">SChar</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SDouble"><span class="hs-identifier">SDouble</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SFloat"><span class="hs-identifier">SFloat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>                                </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt8"><span class="hs-identifier">SInt8</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt16"><span class="hs-identifier">SInt16</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt32"><span class="hs-identifier">SInt32</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt64"><span class="hs-identifier">SInt64</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInteger"><span class="hs-identifier">SInteger</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SList"><span class="hs-identifier">SList</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-29"></span><span>                                </span><span class="annot"><a href="Data.SBV.Core.Data.html#SReal"><span class="hs-identifier">SReal</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SString"><span class="hs-identifier">SString</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SV"><span class="hs-identifier">SV</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord8"><span class="hs-identifier">SWord8</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord16"><span class="hs-identifier">SWord16</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord32"><span class="hs-identifier">SWord32</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>                                </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord64"><span class="hs-identifier">SWord64</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SEither"><span class="hs-identifier">SEither</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SMaybe"><span class="hs-identifier">SMaybe</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SSet"><span class="hs-identifier">SSet</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html"><span class="hs-identifier">Data.SBV.Core.Sized</span></a></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier">SInt</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier">SWord</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier">IntN</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier">WordN</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#IsNonZero"><span class="hs-identifier">IsNonZero</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.SBV.Core.Model.html"><span class="hs-identifier">Data.SBV.Core.Model</span></a></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Model.html#Metric"><span class="hs-identifier">Metric</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Model.html#SymTuple"><span class="hs-identifier">SymTuple</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html"><span class="hs-identifier">Data.SBV.Core.Symbolic</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Objective"><span class="hs-identifier">Objective</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#OptimizeStyle"><span class="hs-identifier">OptimizeStyle</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Quantifier"><span class="hs-identifier">Quantifier</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Result"><span class="hs-identifier">Result</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-34"></span><span>                                </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier">Symbolic</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SBVRunMode"><span class="hs-identifier">SBVRunMode</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SMTConfig"><span class="hs-identifier">SMTConfig</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SVal"><span class="hs-identifier">SVal</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.SBV.Control.Types.html"><span class="hs-identifier">Data.SBV.Control.Types</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Control.Types.html#SMTOption"><span class="hs-identifier">SMTOption</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html"><span class="hs-identifier">Data.SBV.Provers.Prover</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier">Provable</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#SExecutable"><span class="hs-identifier">SExecutable</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#ThmResult"><span class="hs-identifier">ThmResult</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html"><span class="hs-identifier">Data.SBV.SMT.SMT</span></a></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.SMT.SMT.html#AllSatResult"><span class="hs-identifier">AllSatResult</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#SafeResult"><span class="hs-identifier">SafeResult</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#SatResult"><span class="hs-identifier">SatResult</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-38"></span><span>                                </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#OptimizeResult"><span class="hs-identifier">OptimizeResult</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-39"></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.TypeLits</span></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Kind</span></span><span>
</span><span id="line-42"></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Int</span></span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Word</span></span><span>
</span><span id="line-45"></span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html"><span class="hs-identifier">Data.SBV.Core.Data</span></a></span><span>      </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Trans</span></span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html"><span class="hs-identifier">Data.SBV.Core.Sized</span></a></span><span>     </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Trans</span></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Data.SBV.Core.Model.html"><span class="hs-identifier">Data.SBV.Core.Model</span></a></span><span>     </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Trans</span></span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html"><span class="hs-identifier">Data.SBV.Core.Symbolic</span></a></span><span>  </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Trans</span></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html"><span class="hs-identifier">Data.SBV.Provers.Prover</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Trans</span></span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span class="hs-comment">-- Data.SBV.Provers.Prover:</span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span class="hs-comment">-- | Turns a value into a universally quantified predicate, internally naming the inputs.</span><span>
</span><span id="line-55"></span><span class="hs-comment">-- In this case the sbv library will use names of the form @s1, s2@, etc. to name these variables</span><span>
</span><span id="line-56"></span><span class="hs-comment">-- Example:</span><span>
</span><span id="line-57"></span><span class="hs-comment">--</span><span>
</span><span id="line-58"></span><span class="hs-comment">-- &gt;  forAll_ $ \(x::SWord8) y -&gt; x `shiftL` 2 .== y</span><span>
</span><span id="line-59"></span><span class="hs-comment">--</span><span>
</span><span id="line-60"></span><span class="hs-comment">-- is a predicate with two arguments, captured using an ordinary Haskell function. Internally,</span><span>
</span><span id="line-61"></span><span class="hs-comment">-- @x@ will be named @s0@ and @y@ will be named @s1@.</span><span>
</span><span id="line-62"></span><span class="hs-comment">--</span><span>
</span><span id="line-63"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.forAll_'</span><span>
</span><span id="line-64"></span><span id="local-6989586621681156536"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#forAll_"><span class="hs-identifier hs-type">forAll_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156536"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156536"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBool"><span class="hs-identifier hs-type">SBool</span></a></span></span><span>
</span><span id="line-65"></span><span id="forAll_"><span class="annot"><span class="annottext">forAll_ :: a -&gt; Symbolic SBool
</span><a href="Data.SBV.Client.BaseIO.html#forAll_"><span class="hs-identifier hs-var hs-var">forAll_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Symbolic SBool
forall (m :: * -&gt; *) a. MProvable m a =&gt; a -&gt; SymbolicT m SBool
</span><a href="Data.SBV.Provers.Prover.html#forAll_"><span class="hs-identifier hs-var">Trans.forAll_</span></a></span><span>
</span><span id="line-66"></span><span>
</span><span id="line-67"></span><span class="hs-comment">-- | Turns a value into a predicate, allowing users to provide names for the inputs.</span><span>
</span><span id="line-68"></span><span class="hs-comment">-- If the user does not provide enough number of names for the variables, the remaining ones</span><span>
</span><span id="line-69"></span><span class="hs-comment">-- will be internally generated. Note that the names are only used for printing models and has no</span><span>
</span><span id="line-70"></span><span class="hs-comment">-- other significance; in particular, we do not check that they are unique. Example:</span><span>
</span><span id="line-71"></span><span class="hs-comment">--</span><span>
</span><span id="line-72"></span><span class="hs-comment">-- &gt;  forAll [&quot;x&quot;, &quot;y&quot;] $ \(x::SWord8) y -&gt; x `shiftL` 2 .== y</span><span>
</span><span id="line-73"></span><span class="hs-comment">--</span><span>
</span><span id="line-74"></span><span class="hs-comment">-- This is the same as above, except the variables will be named @x@ and @y@ respectively,</span><span>
</span><span id="line-75"></span><span class="hs-comment">-- simplifying the counter-examples when they are printed.</span><span>
</span><span id="line-76"></span><span class="hs-comment">--</span><span>
</span><span id="line-77"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.forAll'</span><span>
</span><span id="line-78"></span><span id="local-6989586621681156533"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#forAll"><span class="hs-identifier hs-type">forAll</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156533"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156533"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBool"><span class="hs-identifier hs-type">SBool</span></a></span></span><span>
</span><span id="line-79"></span><span id="forAll"><span class="annot"><span class="annottext">forAll :: [String] -&gt; a -&gt; Symbolic SBool
</span><a href="Data.SBV.Client.BaseIO.html#forAll"><span class="hs-identifier hs-var hs-var">forAll</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; a -&gt; Symbolic SBool
forall (m :: * -&gt; *) a.
MProvable m a =&gt;
[String] -&gt; a -&gt; SymbolicT m SBool
</span><a href="Data.SBV.Provers.Prover.html#forAll"><span class="hs-identifier hs-var">Trans.forAll</span></a></span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span class="hs-comment">-- | Turns a value into an existentially quantified predicate. (Indeed, 'exists' would have been</span><span>
</span><span id="line-82"></span><span class="hs-comment">-- a better choice here for the name, but alas it's already taken.)</span><span>
</span><span id="line-83"></span><span class="hs-comment">--</span><span>
</span><span id="line-84"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.forSome_'</span><span>
</span><span id="line-85"></span><span id="local-6989586621681156530"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#forSome_"><span class="hs-identifier hs-type">forSome_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156530"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156530"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBool"><span class="hs-identifier hs-type">SBool</span></a></span></span><span>
</span><span id="line-86"></span><span id="forSome_"><span class="annot"><span class="annottext">forSome_ :: a -&gt; Symbolic SBool
</span><a href="Data.SBV.Client.BaseIO.html#forSome_"><span class="hs-identifier hs-var hs-var">forSome_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Symbolic SBool
forall (m :: * -&gt; *) a. MProvable m a =&gt; a -&gt; SymbolicT m SBool
</span><a href="Data.SBV.Provers.Prover.html#forSome_"><span class="hs-identifier hs-var">Trans.forSome_</span></a></span><span>
</span><span id="line-87"></span><span>
</span><span id="line-88"></span><span class="hs-comment">-- | Version of 'forSome' that allows user defined names.</span><span>
</span><span id="line-89"></span><span class="hs-comment">--</span><span>
</span><span id="line-90"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.forSome'</span><span>
</span><span id="line-91"></span><span id="local-6989586621681156527"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#forSome"><span class="hs-identifier hs-type">forSome</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156527"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156527"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBool"><span class="hs-identifier hs-type">SBool</span></a></span></span><span>
</span><span id="line-92"></span><span id="forSome"><span class="annot"><span class="annottext">forSome :: [String] -&gt; a -&gt; Symbolic SBool
</span><a href="Data.SBV.Client.BaseIO.html#forSome"><span class="hs-identifier hs-var hs-var">forSome</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; a -&gt; Symbolic SBool
forall (m :: * -&gt; *) a.
MProvable m a =&gt;
[String] -&gt; a -&gt; SymbolicT m SBool
</span><a href="Data.SBV.Provers.Prover.html#forSome"><span class="hs-identifier hs-var">Trans.forSome</span></a></span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span class="hs-comment">-- | Prove a predicate, using the default solver.</span><span>
</span><span id="line-95"></span><span class="hs-comment">--</span><span>
</span><span id="line-96"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.prove'</span><span>
</span><span id="line-97"></span><span id="local-6989586621681156524"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#prove"><span class="hs-identifier hs-type">prove</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156524"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156524"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#ThmResult"><span class="hs-identifier hs-type">ThmResult</span></a></span></span><span>
</span><span id="line-98"></span><span id="prove"><span class="annot"><span class="annottext">prove :: a -&gt; IO ThmResult
</span><a href="Data.SBV.Client.BaseIO.html#prove"><span class="hs-identifier hs-var hs-var">prove</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; IO ThmResult
forall (m :: * -&gt; *) a. MProvable m a =&gt; a -&gt; m ThmResult
</span><a href="Data.SBV.Provers.Prover.html#prove"><span class="hs-identifier hs-var">Trans.prove</span></a></span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span class="hs-comment">-- | Prove the predicate using the given SMT-solver.</span><span>
</span><span id="line-101"></span><span class="hs-comment">--</span><span>
</span><span id="line-102"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.proveWith'</span><span>
</span><span id="line-103"></span><span id="local-6989586621681156521"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#proveWith"><span class="hs-identifier hs-type">proveWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156521"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SMTConfig"><span class="hs-identifier hs-type">SMTConfig</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156521"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#ThmResult"><span class="hs-identifier hs-type">ThmResult</span></a></span></span><span>
</span><span id="line-104"></span><span id="proveWith"><span class="annot"><span class="annottext">proveWith :: SMTConfig -&gt; a -&gt; IO ThmResult
</span><a href="Data.SBV.Client.BaseIO.html#proveWith"><span class="hs-identifier hs-var hs-var">proveWith</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SMTConfig -&gt; a -&gt; IO ThmResult
forall (m :: * -&gt; *) a.
MProvable m a =&gt;
SMTConfig -&gt; a -&gt; m ThmResult
</span><a href="Data.SBV.Provers.Prover.html#proveWith"><span class="hs-identifier hs-var">Trans.proveWith</span></a></span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span class="hs-comment">-- | Find a satisfying assignment for a predicate, using the default solver.</span><span>
</span><span id="line-107"></span><span class="hs-comment">--</span><span>
</span><span id="line-108"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sat'</span><span>
</span><span id="line-109"></span><span id="local-6989586621681156518"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sat"><span class="hs-identifier hs-type">sat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156518"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156518"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#SatResult"><span class="hs-identifier hs-type">SatResult</span></a></span></span><span>
</span><span id="line-110"></span><span id="sat"><span class="annot"><span class="annottext">sat :: a -&gt; IO SatResult
</span><a href="Data.SBV.Client.BaseIO.html#sat"><span class="hs-identifier hs-var hs-var">sat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; IO SatResult
forall (m :: * -&gt; *) a. MProvable m a =&gt; a -&gt; m SatResult
</span><a href="Data.SBV.Provers.Prover.html#sat"><span class="hs-identifier hs-var">Trans.sat</span></a></span><span>
</span><span id="line-111"></span><span>
</span><span id="line-112"></span><span class="hs-comment">-- | Find a satisfying assignment using the given SMT-solver.</span><span>
</span><span id="line-113"></span><span class="hs-comment">--</span><span>
</span><span id="line-114"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.satWith'</span><span>
</span><span id="line-115"></span><span id="local-6989586621681156515"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#satWith"><span class="hs-identifier hs-type">satWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156515"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SMTConfig"><span class="hs-identifier hs-type">SMTConfig</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156515"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#SatResult"><span class="hs-identifier hs-type">SatResult</span></a></span></span><span>
</span><span id="line-116"></span><span id="satWith"><span class="annot"><span class="annottext">satWith :: SMTConfig -&gt; a -&gt; IO SatResult
</span><a href="Data.SBV.Client.BaseIO.html#satWith"><span class="hs-identifier hs-var hs-var">satWith</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SMTConfig -&gt; a -&gt; IO SatResult
forall (m :: * -&gt; *) a.
MProvable m a =&gt;
SMTConfig -&gt; a -&gt; m SatResult
</span><a href="Data.SBV.Provers.Prover.html#satWith"><span class="hs-identifier hs-var">Trans.satWith</span></a></span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span class="hs-comment">-- | Find all satisfying assignments, using the default solver.</span><span>
</span><span id="line-119"></span><span class="hs-comment">-- Equivalent to @'allSatWith' 'Data.SBV.defaultSMTCfg'@. See 'allSatWith' for details.</span><span>
</span><span id="line-120"></span><span class="hs-comment">--</span><span>
</span><span id="line-121"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.allSat'</span><span>
</span><span id="line-122"></span><span id="local-6989586621681156512"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#allSat"><span class="hs-identifier hs-type">allSat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156512"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156512"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#AllSatResult"><span class="hs-identifier hs-type">AllSatResult</span></a></span></span><span>
</span><span id="line-123"></span><span id="allSat"><span class="annot"><span class="annottext">allSat :: a -&gt; IO AllSatResult
</span><a href="Data.SBV.Client.BaseIO.html#allSat"><span class="hs-identifier hs-var hs-var">allSat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; IO AllSatResult
forall (m :: * -&gt; *) a. MProvable m a =&gt; a -&gt; m AllSatResult
</span><a href="Data.SBV.Provers.Prover.html#allSat"><span class="hs-identifier hs-var">Trans.allSat</span></a></span><span>
</span><span id="line-124"></span><span>
</span><span id="line-125"></span><span class="hs-comment">-- | Return all satisfying assignments for a predicate.</span><span>
</span><span id="line-126"></span><span class="hs-comment">-- Note that this call will block until all satisfying assignments are found. If you have a problem</span><span>
</span><span id="line-127"></span><span class="hs-comment">-- with infinitely many satisfying models (consider 'SInteger') or a very large number of them, you</span><span>
</span><span id="line-128"></span><span class="hs-comment">-- might have to wait for a long time. To avoid such cases, use the 'Data.SBV.Core.Symbolic.allSatMaxModelCount'</span><span>
</span><span id="line-129"></span><span class="hs-comment">-- parameter in the configuration.</span><span>
</span><span id="line-130"></span><span class="hs-comment">--</span><span>
</span><span id="line-131"></span><span class="hs-comment">-- NB. Uninterpreted constant/function values and counter-examples for array values are ignored for</span><span>
</span><span id="line-132"></span><span class="hs-comment">-- the purposes of 'allSat'. That is, only the satisfying assignments modulo uninterpreted functions and</span><span>
</span><span id="line-133"></span><span class="hs-comment">-- array inputs will be returned. This is due to the limitation of not having a robust means of getting a</span><span>
</span><span id="line-134"></span><span class="hs-comment">-- function counter-example back from the SMT solver.</span><span>
</span><span id="line-135"></span><span class="hs-comment">--  Find all satisfying assignments using the given SMT-solver</span><span>
</span><span id="line-136"></span><span class="hs-comment">--</span><span>
</span><span id="line-137"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.allSatWith'</span><span>
</span><span id="line-138"></span><span id="local-6989586621681156509"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#allSatWith"><span class="hs-identifier hs-type">allSatWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156509"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SMTConfig"><span class="hs-identifier hs-type">SMTConfig</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156509"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#AllSatResult"><span class="hs-identifier hs-type">AllSatResult</span></a></span></span><span>
</span><span id="line-139"></span><span id="allSatWith"><span class="annot"><span class="annottext">allSatWith :: SMTConfig -&gt; a -&gt; IO AllSatResult
</span><a href="Data.SBV.Client.BaseIO.html#allSatWith"><span class="hs-identifier hs-var hs-var">allSatWith</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SMTConfig -&gt; a -&gt; IO AllSatResult
forall (m :: * -&gt; *) a.
MProvable m a =&gt;
SMTConfig -&gt; a -&gt; m AllSatResult
</span><a href="Data.SBV.Provers.Prover.html#allSatWith"><span class="hs-identifier hs-var">Trans.allSatWith</span></a></span><span>
</span><span id="line-140"></span><span>
</span><span id="line-141"></span><span class="hs-comment">-- | Optimize a given collection of `Objective`s.</span><span>
</span><span id="line-142"></span><span class="hs-comment">--</span><span>
</span><span id="line-143"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.optimize'</span><span>
</span><span id="line-144"></span><span id="local-6989586621681156506"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#optimize"><span class="hs-identifier hs-type">optimize</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156506"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#OptimizeStyle"><span class="hs-identifier hs-type">OptimizeStyle</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156506"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#OptimizeResult"><span class="hs-identifier hs-type">OptimizeResult</span></a></span></span><span>
</span><span id="line-145"></span><span id="optimize"><span class="annot"><span class="annottext">optimize :: OptimizeStyle -&gt; a -&gt; IO OptimizeResult
</span><a href="Data.SBV.Client.BaseIO.html#optimize"><span class="hs-identifier hs-var hs-var">optimize</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OptimizeStyle -&gt; a -&gt; IO OptimizeResult
forall (m :: * -&gt; *) a.
MProvable m a =&gt;
OptimizeStyle -&gt; a -&gt; m OptimizeResult
</span><a href="Data.SBV.Provers.Prover.html#optimize"><span class="hs-identifier hs-var">Trans.optimize</span></a></span><span>
</span><span id="line-146"></span><span>
</span><span id="line-147"></span><span class="hs-comment">-- | Optimizes the objectives using the given SMT-solver.</span><span>
</span><span id="line-148"></span><span class="hs-comment">--</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.optimizeWith'</span><span>
</span><span id="line-150"></span><span id="local-6989586621681156503"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#optimizeWith"><span class="hs-identifier hs-type">optimizeWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156503"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SMTConfig"><span class="hs-identifier hs-type">SMTConfig</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#OptimizeStyle"><span class="hs-identifier hs-type">OptimizeStyle</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156503"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="Data.SBV.SMT.SMT.html#OptimizeResult"><span class="hs-identifier hs-type">OptimizeResult</span></a></span></span><span>
</span><span id="line-151"></span><span id="optimizeWith"><span class="annot"><span class="annottext">optimizeWith :: SMTConfig -&gt; OptimizeStyle -&gt; a -&gt; IO OptimizeResult
</span><a href="Data.SBV.Client.BaseIO.html#optimizeWith"><span class="hs-identifier hs-var hs-var">optimizeWith</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SMTConfig -&gt; OptimizeStyle -&gt; a -&gt; IO OptimizeResult
forall (m :: * -&gt; *) a.
MProvable m a =&gt;
SMTConfig -&gt; OptimizeStyle -&gt; a -&gt; m OptimizeResult
</span><a href="Data.SBV.Provers.Prover.html#optimizeWith"><span class="hs-identifier hs-var">Trans.optimizeWith</span></a></span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span class="hs-comment">-- | Check if the constraints given are consistent, using the default solver.</span><span>
</span><span id="line-154"></span><span class="hs-comment">--</span><span>
</span><span id="line-155"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.isVacuous'</span><span>
</span><span id="line-156"></span><span id="local-6989586621681156500"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#isVacuous"><span class="hs-identifier hs-type">isVacuous</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156500"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156500"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-157"></span><span id="isVacuous"><span class="annot"><span class="annottext">isVacuous :: a -&gt; IO Bool
</span><a href="Data.SBV.Client.BaseIO.html#isVacuous"><span class="hs-identifier hs-var hs-var">isVacuous</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; IO Bool
forall (m :: * -&gt; *) a. MProvable m a =&gt; a -&gt; m Bool
</span><a href="Data.SBV.Provers.Prover.html#isVacuous"><span class="hs-identifier hs-var">Trans.isVacuous</span></a></span><span>
</span><span id="line-158"></span><span>
</span><span id="line-159"></span><span class="hs-comment">-- | Determine if the constraints are vacuous using the given SMT-solver.</span><span>
</span><span id="line-160"></span><span class="hs-comment">--</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.isVacuousWith'</span><span>
</span><span id="line-162"></span><span id="local-6989586621681156497"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#isVacuousWith"><span class="hs-identifier hs-type">isVacuousWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156497"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SMTConfig"><span class="hs-identifier hs-type">SMTConfig</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156497"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-163"></span><span id="isVacuousWith"><span class="annot"><span class="annottext">isVacuousWith :: SMTConfig -&gt; a -&gt; IO Bool
</span><a href="Data.SBV.Client.BaseIO.html#isVacuousWith"><span class="hs-identifier hs-var hs-var">isVacuousWith</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SMTConfig -&gt; a -&gt; IO Bool
forall (m :: * -&gt; *) a. MProvable m a =&gt; SMTConfig -&gt; a -&gt; m Bool
</span><a href="Data.SBV.Provers.Prover.html#isVacuousWith"><span class="hs-identifier hs-var">Trans.isVacuousWith</span></a></span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span class="hs-comment">-- | Checks theoremhood using the default solver.</span><span>
</span><span id="line-166"></span><span class="hs-comment">--</span><span>
</span><span id="line-167"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.isTheorem'</span><span>
</span><span id="line-168"></span><span id="local-6989586621681156494"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#isTheorem"><span class="hs-identifier hs-type">isTheorem</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156494"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156494"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-169"></span><span id="isTheorem"><span class="annot"><span class="annottext">isTheorem :: a -&gt; IO Bool
</span><a href="Data.SBV.Client.BaseIO.html#isTheorem"><span class="hs-identifier hs-var hs-var">isTheorem</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; IO Bool
forall (m :: * -&gt; *) a. MProvable m a =&gt; a -&gt; m Bool
</span><a href="Data.SBV.Provers.Prover.html#isTheorem"><span class="hs-identifier hs-var">Trans.isTheorem</span></a></span><span>
</span><span id="line-170"></span><span>
</span><span id="line-171"></span><span class="hs-comment">-- | Check whether a given property is a theorem.</span><span>
</span><span id="line-172"></span><span class="hs-comment">--</span><span>
</span><span id="line-173"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.isTheoremWith'</span><span>
</span><span id="line-174"></span><span id="local-6989586621681156491"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#isTheoremWith"><span class="hs-identifier hs-type">isTheoremWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156491"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SMTConfig"><span class="hs-identifier hs-type">SMTConfig</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156491"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-175"></span><span id="isTheoremWith"><span class="annot"><span class="annottext">isTheoremWith :: SMTConfig -&gt; a -&gt; IO Bool
</span><a href="Data.SBV.Client.BaseIO.html#isTheoremWith"><span class="hs-identifier hs-var hs-var">isTheoremWith</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SMTConfig -&gt; a -&gt; IO Bool
forall (m :: * -&gt; *) a. MProvable m a =&gt; SMTConfig -&gt; a -&gt; m Bool
</span><a href="Data.SBV.Provers.Prover.html#isTheoremWith"><span class="hs-identifier hs-var">Trans.isTheoremWith</span></a></span><span>
</span><span id="line-176"></span><span>
</span><span id="line-177"></span><span class="hs-comment">-- | Checks satisfiability using the default solver.</span><span>
</span><span id="line-178"></span><span class="hs-comment">--</span><span>
</span><span id="line-179"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.isSatisfiable'</span><span>
</span><span id="line-180"></span><span id="local-6989586621681156488"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#isSatisfiable"><span class="hs-identifier hs-type">isSatisfiable</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156488"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156488"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-181"></span><span id="isSatisfiable"><span class="annot"><span class="annottext">isSatisfiable :: a -&gt; IO Bool
</span><a href="Data.SBV.Client.BaseIO.html#isSatisfiable"><span class="hs-identifier hs-var hs-var">isSatisfiable</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; IO Bool
forall (m :: * -&gt; *) a. MProvable m a =&gt; a -&gt; m Bool
</span><a href="Data.SBV.Provers.Prover.html#isSatisfiable"><span class="hs-identifier hs-var">Trans.isSatisfiable</span></a></span><span>
</span><span id="line-182"></span><span>
</span><span id="line-183"></span><span class="hs-comment">-- | Check whether a given property is satisfiable.</span><span>
</span><span id="line-184"></span><span class="hs-comment">--</span><span>
</span><span id="line-185"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.isSatisfiableWith'</span><span>
</span><span id="line-186"></span><span id="local-6989586621681156485"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#isSatisfiableWith"><span class="hs-identifier hs-type">isSatisfiableWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#Provable"><span class="hs-identifier hs-type">Provable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156485"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SMTConfig"><span class="hs-identifier hs-type">SMTConfig</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156485"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-187"></span><span id="isSatisfiableWith"><span class="annot"><span class="annottext">isSatisfiableWith :: SMTConfig -&gt; a -&gt; IO Bool
</span><a href="Data.SBV.Client.BaseIO.html#isSatisfiableWith"><span class="hs-identifier hs-var hs-var">isSatisfiableWith</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SMTConfig -&gt; a -&gt; IO Bool
forall (m :: * -&gt; *) a. MProvable m a =&gt; SMTConfig -&gt; a -&gt; m Bool
</span><a href="Data.SBV.Provers.Prover.html#isSatisfiableWith"><span class="hs-identifier hs-var">Trans.isSatisfiableWith</span></a></span><span>
</span><span id="line-188"></span><span>
</span><span id="line-189"></span><span class="hs-comment">-- | Run an arbitrary symbolic computation, equivalent to @'runSMTWith' 'Data.SBV.defaultSMTCfg'@</span><span>
</span><span id="line-190"></span><span class="hs-comment">--</span><span>
</span><span id="line-191"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.runSMT'</span><span>
</span><span id="line-192"></span><span id="local-6989586621681156482"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#runSMT"><span class="hs-identifier hs-type">runSMT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156482"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="#local-6989586621681156482"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-193"></span><span id="runSMT"><span class="annot"><span class="annottext">runSMT :: Symbolic a -&gt; IO a
</span><a href="Data.SBV.Client.BaseIO.html#runSMT"><span class="hs-identifier hs-var hs-var">runSMT</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic a -&gt; IO a
forall (m :: * -&gt; *) a. MonadIO m =&gt; SymbolicT m a -&gt; m a
</span><a href="Data.SBV.Provers.Prover.html#runSMT"><span class="hs-identifier hs-var">Trans.runSMT</span></a></span><span>
</span><span id="line-194"></span><span>
</span><span id="line-195"></span><span class="hs-comment">-- | Runs an arbitrary symbolic computation, exposed to the user in SAT mode</span><span>
</span><span id="line-196"></span><span class="hs-comment">--</span><span>
</span><span id="line-197"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.runSMTWith'</span><span>
</span><span id="line-198"></span><span id="local-6989586621681156479"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#runSMTWith"><span class="hs-identifier hs-type">runSMTWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SMTConfig"><span class="hs-identifier hs-type">SMTConfig</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156479"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="#local-6989586621681156479"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-199"></span><span id="runSMTWith"><span class="annot"><span class="annottext">runSMTWith :: SMTConfig -&gt; Symbolic a -&gt; IO a
</span><a href="Data.SBV.Client.BaseIO.html#runSMTWith"><span class="hs-identifier hs-var hs-var">runSMTWith</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SMTConfig -&gt; Symbolic a -&gt; IO a
forall (m :: * -&gt; *) a.
MonadIO m =&gt;
SMTConfig -&gt; SymbolicT m a -&gt; m a
</span><a href="Data.SBV.Provers.Prover.html#runSMTWith"><span class="hs-identifier hs-var">Trans.runSMTWith</span></a></span><span>
</span><span id="line-200"></span><span>
</span><span id="line-201"></span><span class="hs-comment">-- | NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sName_'</span><span>
</span><span id="line-202"></span><span id="local-6989586621681156476"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sName_"><span class="hs-identifier hs-type">sName_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#SExecutable"><span class="hs-identifier hs-type">SExecutable</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="#local-6989586621681156476"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156476"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-203"></span><span id="sName_"><span class="annot"><span class="annottext">sName_ :: a -&gt; Symbolic ()
</span><a href="Data.SBV.Client.BaseIO.html#sName_"><span class="hs-identifier hs-var hs-var">sName_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Symbolic ()
forall (m :: * -&gt; *) a. SExecutable m a =&gt; a -&gt; SymbolicT m ()
</span><a href="Data.SBV.Provers.Prover.html#sName_"><span class="hs-identifier hs-var">Trans.sName_</span></a></span><span>
</span><span id="line-204"></span><span>
</span><span id="line-205"></span><span class="hs-comment">-- | NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sName'</span><span>
</span><span id="line-206"></span><span id="local-6989586621681156473"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sName"><span class="hs-identifier hs-type">sName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#SExecutable"><span class="hs-identifier hs-type">SExecutable</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="#local-6989586621681156473"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156473"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-207"></span><span id="sName"><span class="annot"><span class="annottext">sName :: [String] -&gt; a -&gt; Symbolic ()
</span><a href="Data.SBV.Client.BaseIO.html#sName"><span class="hs-identifier hs-var hs-var">sName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; a -&gt; Symbolic ()
forall (m :: * -&gt; *) a.
SExecutable m a =&gt;
[String] -&gt; a -&gt; SymbolicT m ()
</span><a href="Data.SBV.Provers.Prover.html#sName"><span class="hs-identifier hs-var">Trans.sName</span></a></span><span>
</span><span id="line-208"></span><span>
</span><span id="line-209"></span><span class="hs-comment">-- | Check safety using the default solver.</span><span>
</span><span id="line-210"></span><span class="hs-comment">--</span><span>
</span><span id="line-211"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.safe'</span><span>
</span><span id="line-212"></span><span id="local-6989586621681156470"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#safe"><span class="hs-keyword hs-type">safe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#SExecutable"><span class="hs-identifier hs-type">SExecutable</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="#local-6989586621681156470"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156470"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.SMT.SMT.html#SafeResult"><span class="hs-identifier hs-type">SafeResult</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-213"></span><span id="safe"><span class="annot"><span class="annottext">safe :: a -&gt; IO [SafeResult]
</span><a href="Data.SBV.Client.BaseIO.html#safe"><span class="hs-keyword hs-var hs-var">safe</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; IO [SafeResult]
forall (m :: * -&gt; *) a. SExecutable m a =&gt; a -&gt; m [SafeResult]
</span><a href="Data.SBV.Provers.Prover.html#safe"><span class="hs-identifier hs-var">Trans.safe</span></a></span><span>
</span><span id="line-214"></span><span>
</span><span id="line-215"></span><span class="hs-comment">-- | Check if any of the 'Data.SBV.sAssert' calls can be violated.</span><span>
</span><span id="line-216"></span><span class="hs-comment">--</span><span>
</span><span id="line-217"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.safeWith'</span><span>
</span><span id="line-218"></span><span id="local-6989586621681156467"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#safeWith"><span class="hs-identifier hs-type">safeWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Provers.Prover.html#SExecutable"><span class="hs-identifier hs-type">SExecutable</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="#local-6989586621681156467"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SMTConfig"><span class="hs-identifier hs-type">SMTConfig</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156467"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.SMT.SMT.html#SafeResult"><span class="hs-identifier hs-type">SafeResult</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-219"></span><span id="safeWith"><span class="annot"><span class="annottext">safeWith :: SMTConfig -&gt; a -&gt; IO [SafeResult]
</span><a href="Data.SBV.Client.BaseIO.html#safeWith"><span class="hs-identifier hs-var hs-var">safeWith</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SMTConfig -&gt; a -&gt; IO [SafeResult]
forall (m :: * -&gt; *) a.
SExecutable m a =&gt;
SMTConfig -&gt; a -&gt; m [SafeResult]
</span><a href="Data.SBV.Provers.Prover.html#safeWith"><span class="hs-identifier hs-var">Trans.safeWith</span></a></span><span>
</span><span id="line-220"></span><span>
</span><span id="line-221"></span><span class="hs-comment">-- Data.SBV.Core.Data:</span><span>
</span><span id="line-222"></span><span>
</span><span id="line-223"></span><span class="hs-comment">-- | Create a symbolic variable.</span><span>
</span><span id="line-224"></span><span class="hs-comment">--</span><span>
</span><span id="line-225"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.mkSymSBV'</span><span>
</span><span id="line-226"></span><span id="local-6989586621681156464"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#mkSymSBV"><span class="hs-identifier hs-type">mkSymSBV</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Quantifier"><span class="hs-identifier hs-type">Quantifier</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Kind.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156464"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-227"></span><span id="mkSymSBV"><span class="annot"><span class="annottext">mkSymSBV :: Maybe Quantifier -&gt; Kind -&gt; Maybe String -&gt; Symbolic (SBV a)
</span><a href="Data.SBV.Client.BaseIO.html#mkSymSBV"><span class="hs-identifier hs-var hs-var">mkSymSBV</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Quantifier -&gt; Kind -&gt; Maybe String -&gt; Symbolic (SBV a)
forall a (m :: * -&gt; *).
MonadSymbolic m =&gt;
Maybe Quantifier -&gt; Kind -&gt; Maybe String -&gt; m (SBV a)
</span><a href="Data.SBV.Core.Data.html#mkSymSBV"><span class="hs-identifier hs-var">Trans.mkSymSBV</span></a></span><span>
</span><span id="line-228"></span><span>
</span><span id="line-229"></span><span class="hs-comment">-- | Convert a symbolic value to an SV, inside the Symbolic monad</span><span>
</span><span id="line-230"></span><span class="hs-comment">--</span><span>
</span><span id="line-231"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sbvToSymSV'</span><span>
</span><span id="line-232"></span><span id="local-6989586621681156461"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sbvToSymSV"><span class="hs-identifier hs-type">sbvToSymSV</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156461"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SV"><span class="hs-identifier hs-type">SV</span></a></span></span><span>
</span><span id="line-233"></span><span id="sbvToSymSV"><span class="annot"><span class="annottext">sbvToSymSV :: SBV a -&gt; Symbolic SV
</span><a href="Data.SBV.Client.BaseIO.html#sbvToSymSV"><span class="hs-identifier hs-var hs-var">sbvToSymSV</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SBV a -&gt; Symbolic SV
forall (m :: * -&gt; *) a. MonadSymbolic m =&gt; SBV a -&gt; m SV
</span><a href="Data.SBV.Core.Data.html#sbvToSymSV"><span class="hs-identifier hs-var">Trans.sbvToSymSV</span></a></span><span>
</span><span id="line-234"></span><span>
</span><span id="line-235"></span><span class="hs-comment">-- | Mark an interim result as an output. Useful when constructing Symbolic programs</span><span>
</span><span id="line-236"></span><span class="hs-comment">-- that return multiple values, or when the result is programmatically computed.</span><span>
</span><span id="line-237"></span><span class="hs-comment">--</span><span>
</span><span id="line-238"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.output'</span><span>
</span><span id="line-239"></span><span id="local-6989586621681156458"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#output"><span class="hs-identifier hs-type">output</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#Outputtable"><span class="hs-identifier hs-type">Outputtable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156458"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156458"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156458"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-240"></span><span id="output"><span class="annot"><span class="annottext">output :: a -&gt; Symbolic a
</span><a href="Data.SBV.Client.BaseIO.html#output"><span class="hs-identifier hs-var hs-var">output</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Symbolic a
forall a (m :: * -&gt; *).
(Outputtable a, MonadSymbolic m) =&gt;
a -&gt; m a
</span><a href="Data.SBV.Core.Data.html#output"><span class="hs-identifier hs-var">Trans.output</span></a></span><span>
</span><span id="line-241"></span><span>
</span><span id="line-242"></span><span class="hs-comment">-- | Create a user named input (universal)</span><span>
</span><span id="line-243"></span><span class="hs-comment">--</span><span>
</span><span id="line-244"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.forall'</span><span>
</span><span id="line-245"></span><span id="local-6989586621681156455"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#forall"><span class="hs-keyword hs-type">forall</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156455"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156455"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-246"></span><span id="forall"><span class="annot"><span class="annottext">forall :: String -&gt; Symbolic (SBV a)
</span><a href="Data.SBV.Client.BaseIO.html#forall"><span class="hs-keyword hs-var hs-var">forall</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic (SBV a)
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
String -&gt; m (SBV a)
</span><a href="Data.SBV.Core.Data.html#forall"><span class="hs-identifier hs-var">Trans.forall</span></a></span><span>
</span><span id="line-247"></span><span>
</span><span id="line-248"></span><span class="hs-comment">-- | Create an automatically named input</span><span>
</span><span id="line-249"></span><span class="hs-comment">--</span><span>
</span><span id="line-250"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.forall_'</span><span>
</span><span id="line-251"></span><span id="local-6989586621681156452"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#forall_"><span class="hs-identifier hs-type">forall_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156452"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156452"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-252"></span><span id="forall_"><span class="annot"><span class="annottext">forall_ :: Symbolic (SBV a)
</span><a href="Data.SBV.Client.BaseIO.html#forall_"><span class="hs-identifier hs-var hs-var">forall_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic (SBV a)
forall a (m :: * -&gt; *). (SymVal a, MonadSymbolic m) =&gt; m (SBV a)
</span><a href="Data.SBV.Core.Data.html#forall_"><span class="hs-identifier hs-var">Trans.forall_</span></a></span><span>
</span><span id="line-253"></span><span>
</span><span id="line-254"></span><span class="hs-comment">-- | Get a bunch of new words</span><span>
</span><span id="line-255"></span><span class="hs-comment">--</span><span>
</span><span id="line-256"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.mkForallVars'</span><span>
</span><span id="line-257"></span><span id="local-6989586621681156449"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#mkForallVars"><span class="hs-identifier hs-type">mkForallVars</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156449"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156449"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-258"></span><span id="mkForallVars"><span class="annot"><span class="annottext">mkForallVars :: Int -&gt; Symbolic [SBV a]
</span><a href="Data.SBV.Client.BaseIO.html#mkForallVars"><span class="hs-identifier hs-var hs-var">mkForallVars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Symbolic [SBV a]
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
Int -&gt; m [SBV a]
</span><a href="Data.SBV.Core.Data.html#mkForallVars"><span class="hs-identifier hs-var">Trans.mkForallVars</span></a></span><span>
</span><span id="line-259"></span><span>
</span><span id="line-260"></span><span class="hs-comment">-- | Create an existential variable</span><span>
</span><span id="line-261"></span><span class="hs-comment">--</span><span>
</span><span id="line-262"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.exists'</span><span>
</span><span id="line-263"></span><span id="local-6989586621681156446"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#exists"><span class="hs-identifier hs-type">exists</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156446"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156446"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-264"></span><span id="exists"><span class="annot"><span class="annottext">exists :: String -&gt; Symbolic (SBV a)
</span><a href="Data.SBV.Client.BaseIO.html#exists"><span class="hs-identifier hs-var hs-var">exists</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic (SBV a)
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
String -&gt; m (SBV a)
</span><a href="Data.SBV.Core.Data.html#exists"><span class="hs-identifier hs-var">Trans.exists</span></a></span><span>
</span><span id="line-265"></span><span>
</span><span id="line-266"></span><span class="hs-comment">-- | Create an automatically named existential variable</span><span>
</span><span id="line-267"></span><span class="hs-comment">--</span><span>
</span><span id="line-268"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.exists_'</span><span>
</span><span id="line-269"></span><span id="local-6989586621681156443"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#exists_"><span class="hs-identifier hs-type">exists_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156443"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156443"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-270"></span><span id="exists_"><span class="annot"><span class="annottext">exists_ :: Symbolic (SBV a)
</span><a href="Data.SBV.Client.BaseIO.html#exists_"><span class="hs-identifier hs-var hs-var">exists_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic (SBV a)
forall a (m :: * -&gt; *). (SymVal a, MonadSymbolic m) =&gt; m (SBV a)
</span><a href="Data.SBV.Core.Data.html#exists_"><span class="hs-identifier hs-var">Trans.exists_</span></a></span><span>
</span><span id="line-271"></span><span>
</span><span id="line-272"></span><span class="hs-comment">-- | Create a bunch of existentials</span><span>
</span><span id="line-273"></span><span class="hs-comment">--</span><span>
</span><span id="line-274"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.mkExistVars'</span><span>
</span><span id="line-275"></span><span id="local-6989586621681156440"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#mkExistVars"><span class="hs-identifier hs-type">mkExistVars</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156440"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156440"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-276"></span><span id="mkExistVars"><span class="annot"><span class="annottext">mkExistVars :: Int -&gt; Symbolic [SBV a]
</span><a href="Data.SBV.Client.BaseIO.html#mkExistVars"><span class="hs-identifier hs-var hs-var">mkExistVars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Symbolic [SBV a]
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
Int -&gt; m [SBV a]
</span><a href="Data.SBV.Core.Data.html#mkExistVars"><span class="hs-identifier hs-var">Trans.mkExistVars</span></a></span><span>
</span><span id="line-277"></span><span>
</span><span id="line-278"></span><span class="hs-comment">-- | Create a free variable, universal in a proof, existential in sat</span><span>
</span><span id="line-279"></span><span class="hs-comment">--</span><span>
</span><span id="line-280"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.free'</span><span>
</span><span id="line-281"></span><span id="local-6989586621681156437"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#free"><span class="hs-identifier hs-type">free</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156437"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156437"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-282"></span><span id="free"><span class="annot"><span class="annottext">free :: String -&gt; Symbolic (SBV a)
</span><a href="Data.SBV.Client.BaseIO.html#free"><span class="hs-identifier hs-var hs-var">free</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic (SBV a)
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
String -&gt; m (SBV a)
</span><a href="Data.SBV.Core.Data.html#free"><span class="hs-identifier hs-var">Trans.free</span></a></span><span>
</span><span id="line-283"></span><span>
</span><span id="line-284"></span><span class="hs-comment">-- | Create an unnamed free variable, universal in proof, existential in sat</span><span>
</span><span id="line-285"></span><span class="hs-comment">--</span><span>
</span><span id="line-286"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.free_'</span><span>
</span><span id="line-287"></span><span id="local-6989586621681156434"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#free_"><span class="hs-identifier hs-type">free_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156434"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156434"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-288"></span><span id="free_"><span class="annot"><span class="annottext">free_ :: Symbolic (SBV a)
</span><a href="Data.SBV.Client.BaseIO.html#free_"><span class="hs-identifier hs-var hs-var">free_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic (SBV a)
forall a (m :: * -&gt; *). (SymVal a, MonadSymbolic m) =&gt; m (SBV a)
</span><a href="Data.SBV.Core.Data.html#free_"><span class="hs-identifier hs-var">Trans.free_</span></a></span><span>
</span><span id="line-289"></span><span>
</span><span id="line-290"></span><span class="hs-comment">-- | Create a bunch of free vars</span><span>
</span><span id="line-291"></span><span class="hs-comment">--</span><span>
</span><span id="line-292"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.mkFreeVars'</span><span>
</span><span id="line-293"></span><span id="local-6989586621681156431"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#mkFreeVars"><span class="hs-identifier hs-type">mkFreeVars</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156431"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156431"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-294"></span><span id="mkFreeVars"><span class="annot"><span class="annottext">mkFreeVars :: Int -&gt; Symbolic [SBV a]
</span><a href="Data.SBV.Client.BaseIO.html#mkFreeVars"><span class="hs-identifier hs-var hs-var">mkFreeVars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Symbolic [SBV a]
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
Int -&gt; m [SBV a]
</span><a href="Data.SBV.Core.Data.html#mkFreeVars"><span class="hs-identifier hs-var">Trans.mkFreeVars</span></a></span><span>
</span><span id="line-295"></span><span>
</span><span id="line-296"></span><span class="hs-comment">-- | Similar to free; Just a more convenient name</span><span>
</span><span id="line-297"></span><span class="hs-comment">--</span><span>
</span><span id="line-298"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.symbolic'</span><span>
</span><span id="line-299"></span><span id="local-6989586621681156428"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#symbolic"><span class="hs-identifier hs-type">symbolic</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156428"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156428"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-300"></span><span id="symbolic"><span class="annot"><span class="annottext">symbolic :: String -&gt; Symbolic (SBV a)
</span><a href="Data.SBV.Client.BaseIO.html#symbolic"><span class="hs-identifier hs-var hs-var">symbolic</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic (SBV a)
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
String -&gt; m (SBV a)
</span><a href="Data.SBV.Core.Data.html#symbolic"><span class="hs-identifier hs-var">Trans.symbolic</span></a></span><span>
</span><span id="line-301"></span><span>
</span><span id="line-302"></span><span class="hs-comment">-- | Similar to mkFreeVars; but automatically gives names based on the strings</span><span>
</span><span id="line-303"></span><span class="hs-comment">--</span><span>
</span><span id="line-304"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.symbolics'</span><span>
</span><span id="line-305"></span><span id="local-6989586621681156425"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#symbolics"><span class="hs-identifier hs-type">symbolics</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156425"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156425"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-306"></span><span id="symbolics"><span class="annot"><span class="annottext">symbolics :: [String] -&gt; Symbolic [SBV a]
</span><a href="Data.SBV.Client.BaseIO.html#symbolics"><span class="hs-identifier hs-var hs-var">symbolics</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SBV a]
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
[String] -&gt; m [SBV a]
</span><a href="Data.SBV.Core.Data.html#symbolics"><span class="hs-identifier hs-var">Trans.symbolics</span></a></span><span>
</span><span id="line-307"></span><span>
</span><span id="line-308"></span><span class="hs-comment">-- | One stop allocator</span><span>
</span><span id="line-309"></span><span class="hs-comment">--</span><span>
</span><span id="line-310"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.mkSymVal'</span><span>
</span><span id="line-311"></span><span id="local-6989586621681156422"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#mkSymVal"><span class="hs-identifier hs-type">mkSymVal</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156422"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Quantifier"><span class="hs-identifier hs-type">Quantifier</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156422"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-312"></span><span id="mkSymVal"><span class="annot"><span class="annottext">mkSymVal :: Maybe Quantifier -&gt; Maybe String -&gt; Symbolic (SBV a)
</span><a href="Data.SBV.Client.BaseIO.html#mkSymVal"><span class="hs-identifier hs-var hs-var">mkSymVal</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Quantifier -&gt; Maybe String -&gt; Symbolic (SBV a)
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
Maybe Quantifier -&gt; Maybe String -&gt; m (SBV a)
</span><a href="Data.SBV.Core.Data.html#mkSymVal"><span class="hs-identifier hs-var">Trans.mkSymVal</span></a></span><span>
</span><span id="line-313"></span><span>
</span><span id="line-314"></span><span class="hs-comment">-- | Create a new anonymous array, possibly with a default initial value.</span><span>
</span><span id="line-315"></span><span class="hs-comment">--</span><span>
</span><span id="line-316"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.newArray_'</span><span>
</span><span id="line-317"></span><span id="local-6989586621681156417"><span id="local-6989586621681156418"><span id="local-6989586621681156419"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#newArray_"><span class="hs-identifier hs-type">newArray_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SymArray"><span class="hs-identifier hs-type">SymArray</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156419"><span class="hs-identifier hs-type">array</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Kind.html#HasKind"><span class="hs-identifier hs-type">HasKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156418"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Kind.html#HasKind"><span class="hs-identifier hs-type">HasKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156417"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156417"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621681156419"><span class="hs-identifier hs-type">array</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156418"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156417"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-318"></span><span id="newArray_"><span class="annot"><span class="annottext">newArray_ :: Maybe (SBV b) -&gt; Symbolic (array a b)
</span><a href="Data.SBV.Client.BaseIO.html#newArray_"><span class="hs-identifier hs-var hs-var">newArray_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (SBV b) -&gt; Symbolic (array a b)
forall (array :: * -&gt; * -&gt; *) (m :: * -&gt; *) a b.
(SymArray array, MonadSymbolic m, HasKind a, HasKind b) =&gt;
Maybe (SBV b) -&gt; m (array a b)
</span><a href="Data.SBV.Core.Data.html#newArray_"><span class="hs-identifier hs-var">Trans.newArray_</span></a></span><span>
</span><span id="line-319"></span><span>
</span><span id="line-320"></span><span class="hs-comment">-- | Create a named new array, possibly with a default initial value.</span><span>
</span><span id="line-321"></span><span class="hs-comment">--</span><span>
</span><span id="line-322"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.newArray'</span><span>
</span><span id="line-323"></span><span id="local-6989586621681156412"><span id="local-6989586621681156413"><span id="local-6989586621681156414"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#newArray"><span class="hs-identifier hs-type">newArray</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SymArray"><span class="hs-identifier hs-type">SymArray</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156414"><span class="hs-identifier hs-type">array</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Kind.html#HasKind"><span class="hs-identifier hs-type">HasKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156413"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Kind.html#HasKind"><span class="hs-identifier hs-type">HasKind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156412"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156412"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621681156414"><span class="hs-identifier hs-type">array</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156413"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156412"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-324"></span><span id="newArray"><span class="annot"><span class="annottext">newArray :: String -&gt; Maybe (SBV b) -&gt; Symbolic (array a b)
</span><a href="Data.SBV.Client.BaseIO.html#newArray"><span class="hs-identifier hs-var hs-var">newArray</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe (SBV b) -&gt; Symbolic (array a b)
forall (array :: * -&gt; * -&gt; *) (m :: * -&gt; *) a b.
(SymArray array, MonadSymbolic m, HasKind a, HasKind b) =&gt;
String -&gt; Maybe (SBV b) -&gt; m (array a b)
</span><a href="Data.SBV.Core.Data.html#newArray"><span class="hs-identifier hs-var">Trans.newArray</span></a></span><span>
</span><span id="line-325"></span><span>
</span><span id="line-326"></span><span class="hs-comment">-- Data.SBV.Core.Model:</span><span>
</span><span id="line-327"></span><span>
</span><span id="line-328"></span><span class="hs-comment">-- | Generically make a symbolic var</span><span>
</span><span id="line-329"></span><span class="hs-comment">--</span><span>
</span><span id="line-330"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.genMkSymVar'</span><span>
</span><span id="line-331"></span><span id="local-6989586621681156409"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#genMkSymVar"><span class="hs-identifier hs-type">genMkSymVar</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Kind.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Quantifier"><span class="hs-identifier hs-type">Quantifier</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156409"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-332"></span><span id="genMkSymVar"><span class="annot"><span class="annottext">genMkSymVar :: Kind -&gt; Maybe Quantifier -&gt; Maybe String -&gt; Symbolic (SBV a)
</span><a href="Data.SBV.Client.BaseIO.html#genMkSymVar"><span class="hs-identifier hs-var hs-var">genMkSymVar</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Kind -&gt; Maybe Quantifier -&gt; Maybe String -&gt; Symbolic (SBV a)
forall (m :: * -&gt; *) a.
MonadSymbolic m =&gt;
Kind -&gt; Maybe Quantifier -&gt; Maybe String -&gt; m (SBV a)
</span><a href="Data.SBV.Core.Model.html#genMkSymVar"><span class="hs-identifier hs-var">Trans.genMkSymVar</span></a></span><span>
</span><span id="line-333"></span><span>
</span><span id="line-334"></span><span class="hs-comment">-- | Declare a named 'SBool'</span><span>
</span><span id="line-335"></span><span class="hs-comment">--</span><span>
</span><span id="line-336"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sBool'</span><span>
</span><span id="line-337"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sBool"><span class="hs-identifier hs-type">sBool</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBool"><span class="hs-identifier hs-type">SBool</span></a></span><span>
</span><span id="line-338"></span><span id="sBool"><span class="annot"><span class="annottext">sBool :: String -&gt; Symbolic SBool
</span><a href="Data.SBV.Client.BaseIO.html#sBool"><span class="hs-identifier hs-var hs-var">sBool</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SBool
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SBool
</span><a href="Data.SBV.Core.Model.html#sBool"><span class="hs-identifier hs-var">Trans.sBool</span></a></span><span>
</span><span id="line-339"></span><span>
</span><span id="line-340"></span><span class="hs-comment">-- | Declare an unnamed 'SBool'</span><span>
</span><span id="line-341"></span><span class="hs-comment">--</span><span>
</span><span id="line-342"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sBool_'</span><span>
</span><span id="line-343"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sBool_"><span class="hs-identifier hs-type">sBool_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBool"><span class="hs-identifier hs-type">SBool</span></a></span><span>
</span><span id="line-344"></span><span id="sBool_"><span class="annot"><span class="annottext">sBool_ :: Symbolic SBool
</span><a href="Data.SBV.Client.BaseIO.html#sBool_"><span class="hs-identifier hs-var hs-var">sBool_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SBool
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SBool
</span><a href="Data.SBV.Core.Model.html#sBool_"><span class="hs-identifier hs-var">Trans.sBool_</span></a></span><span>
</span><span id="line-345"></span><span>
</span><span id="line-346"></span><span class="hs-comment">-- | Declare a list of 'SBool's</span><span>
</span><span id="line-347"></span><span class="hs-comment">--</span><span>
</span><span id="line-348"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sBools'</span><span>
</span><span id="line-349"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sBools"><span class="hs-identifier hs-type">sBools</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBool"><span class="hs-identifier hs-type">SBool</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-350"></span><span id="sBools"><span class="annot"><span class="annottext">sBools :: [String] -&gt; Symbolic [SBool]
</span><a href="Data.SBV.Client.BaseIO.html#sBools"><span class="hs-identifier hs-var hs-var">sBools</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SBool]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SBool]
</span><a href="Data.SBV.Core.Model.html#sBools"><span class="hs-identifier hs-var">Trans.sBools</span></a></span><span>
</span><span id="line-351"></span><span>
</span><span id="line-352"></span><span class="hs-comment">-- | Declare a named 'SWord8'</span><span>
</span><span id="line-353"></span><span class="hs-comment">--</span><span>
</span><span id="line-354"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord8'</span><span>
</span><span id="line-355"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord8"><span class="hs-identifier hs-type">sWord8</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord8"><span class="hs-identifier hs-type">SWord8</span></a></span><span>
</span><span id="line-356"></span><span id="sWord8"><span class="annot"><span class="annottext">sWord8 :: String -&gt; Symbolic SWord8
</span><a href="Data.SBV.Client.BaseIO.html#sWord8"><span class="hs-identifier hs-var hs-var">sWord8</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SWord8
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SWord8
</span><a href="Data.SBV.Core.Model.html#sWord8"><span class="hs-identifier hs-var">Trans.sWord8</span></a></span><span>
</span><span id="line-357"></span><span>
</span><span id="line-358"></span><span class="hs-comment">-- | Declare an unnamed 'SWord8'</span><span>
</span><span id="line-359"></span><span class="hs-comment">--</span><span>
</span><span id="line-360"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord8_'</span><span>
</span><span id="line-361"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord8_"><span class="hs-identifier hs-type">sWord8_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord8"><span class="hs-identifier hs-type">SWord8</span></a></span><span>
</span><span id="line-362"></span><span id="sWord8_"><span class="annot"><span class="annottext">sWord8_ :: Symbolic SWord8
</span><a href="Data.SBV.Client.BaseIO.html#sWord8_"><span class="hs-identifier hs-var hs-var">sWord8_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SWord8
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SWord8
</span><a href="Data.SBV.Core.Model.html#sWord8_"><span class="hs-identifier hs-var">Trans.sWord8_</span></a></span><span>
</span><span id="line-363"></span><span>
</span><span id="line-364"></span><span class="hs-comment">-- | Declare a list of 'SWord8's</span><span>
</span><span id="line-365"></span><span class="hs-comment">--</span><span>
</span><span id="line-366"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord8s'</span><span>
</span><span id="line-367"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord8s"><span class="hs-identifier hs-type">sWord8s</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord8"><span class="hs-identifier hs-type">SWord8</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-368"></span><span id="sWord8s"><span class="annot"><span class="annottext">sWord8s :: [String] -&gt; Symbolic [SWord8]
</span><a href="Data.SBV.Client.BaseIO.html#sWord8s"><span class="hs-identifier hs-var hs-var">sWord8s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SWord8]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SWord8]
</span><a href="Data.SBV.Core.Model.html#sWord8s"><span class="hs-identifier hs-var">Trans.sWord8s</span></a></span><span>
</span><span id="line-369"></span><span>
</span><span id="line-370"></span><span class="hs-comment">-- | Declare a named 'SWord16'</span><span>
</span><span id="line-371"></span><span class="hs-comment">--</span><span>
</span><span id="line-372"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord16'</span><span>
</span><span id="line-373"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord16"><span class="hs-identifier hs-type">sWord16</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord16"><span class="hs-identifier hs-type">SWord16</span></a></span><span>
</span><span id="line-374"></span><span id="sWord16"><span class="annot"><span class="annottext">sWord16 :: String -&gt; Symbolic SWord16
</span><a href="Data.SBV.Client.BaseIO.html#sWord16"><span class="hs-identifier hs-var hs-var">sWord16</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SWord16
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SWord16
</span><a href="Data.SBV.Core.Model.html#sWord16"><span class="hs-identifier hs-var">Trans.sWord16</span></a></span><span>
</span><span id="line-375"></span><span>
</span><span id="line-376"></span><span class="hs-comment">-- | Declare an unnamed 'SWord16'</span><span>
</span><span id="line-377"></span><span class="hs-comment">--</span><span>
</span><span id="line-378"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord16_'</span><span>
</span><span id="line-379"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord16_"><span class="hs-identifier hs-type">sWord16_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord16"><span class="hs-identifier hs-type">SWord16</span></a></span><span>
</span><span id="line-380"></span><span id="sWord16_"><span class="annot"><span class="annottext">sWord16_ :: Symbolic SWord16
</span><a href="Data.SBV.Client.BaseIO.html#sWord16_"><span class="hs-identifier hs-var hs-var">sWord16_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SWord16
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SWord16
</span><a href="Data.SBV.Core.Model.html#sWord16_"><span class="hs-identifier hs-var">Trans.sWord16_</span></a></span><span>
</span><span id="line-381"></span><span>
</span><span id="line-382"></span><span class="hs-comment">-- | Declare a list of 'SWord16's</span><span>
</span><span id="line-383"></span><span class="hs-comment">--</span><span>
</span><span id="line-384"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord16s'</span><span>
</span><span id="line-385"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord16s"><span class="hs-identifier hs-type">sWord16s</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord16"><span class="hs-identifier hs-type">SWord16</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-386"></span><span id="sWord16s"><span class="annot"><span class="annottext">sWord16s :: [String] -&gt; Symbolic [SWord16]
</span><a href="Data.SBV.Client.BaseIO.html#sWord16s"><span class="hs-identifier hs-var hs-var">sWord16s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SWord16]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SWord16]
</span><a href="Data.SBV.Core.Model.html#sWord16s"><span class="hs-identifier hs-var">Trans.sWord16s</span></a></span><span>
</span><span id="line-387"></span><span>
</span><span id="line-388"></span><span class="hs-comment">-- | Declare a named 'SWord32'</span><span>
</span><span id="line-389"></span><span class="hs-comment">--</span><span>
</span><span id="line-390"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord32'</span><span>
</span><span id="line-391"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord32"><span class="hs-identifier hs-type">sWord32</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord32"><span class="hs-identifier hs-type">SWord32</span></a></span><span>
</span><span id="line-392"></span><span id="sWord32"><span class="annot"><span class="annottext">sWord32 :: String -&gt; Symbolic SWord32
</span><a href="Data.SBV.Client.BaseIO.html#sWord32"><span class="hs-identifier hs-var hs-var">sWord32</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SWord32
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SWord32
</span><a href="Data.SBV.Core.Model.html#sWord32"><span class="hs-identifier hs-var">Trans.sWord32</span></a></span><span>
</span><span id="line-393"></span><span>
</span><span id="line-394"></span><span class="hs-comment">-- | Declare an unamed 'SWord32'</span><span>
</span><span id="line-395"></span><span class="hs-comment">--</span><span>
</span><span id="line-396"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord32_'</span><span>
</span><span id="line-397"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord32_"><span class="hs-identifier hs-type">sWord32_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord32"><span class="hs-identifier hs-type">SWord32</span></a></span><span>
</span><span id="line-398"></span><span id="sWord32_"><span class="annot"><span class="annottext">sWord32_ :: Symbolic SWord32
</span><a href="Data.SBV.Client.BaseIO.html#sWord32_"><span class="hs-identifier hs-var hs-var">sWord32_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SWord32
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SWord32
</span><a href="Data.SBV.Core.Model.html#sWord32_"><span class="hs-identifier hs-var">Trans.sWord32_</span></a></span><span>
</span><span id="line-399"></span><span>
</span><span id="line-400"></span><span class="hs-comment">-- | Declare a list of 'SWord32's</span><span>
</span><span id="line-401"></span><span class="hs-comment">--</span><span>
</span><span id="line-402"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord32s'</span><span>
</span><span id="line-403"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord32s"><span class="hs-identifier hs-type">sWord32s</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord32"><span class="hs-identifier hs-type">SWord32</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-404"></span><span id="sWord32s"><span class="annot"><span class="annottext">sWord32s :: [String] -&gt; Symbolic [SWord32]
</span><a href="Data.SBV.Client.BaseIO.html#sWord32s"><span class="hs-identifier hs-var hs-var">sWord32s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SWord32]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SWord32]
</span><a href="Data.SBV.Core.Model.html#sWord32s"><span class="hs-identifier hs-var">Trans.sWord32s</span></a></span><span>
</span><span id="line-405"></span><span>
</span><span id="line-406"></span><span class="hs-comment">-- | Declare a named 'SWord64'</span><span>
</span><span id="line-407"></span><span class="hs-comment">--</span><span>
</span><span id="line-408"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord64'</span><span>
</span><span id="line-409"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord64"><span class="hs-identifier hs-type">sWord64</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord64"><span class="hs-identifier hs-type">SWord64</span></a></span><span>
</span><span id="line-410"></span><span id="sWord64"><span class="annot"><span class="annottext">sWord64 :: String -&gt; Symbolic SWord64
</span><a href="Data.SBV.Client.BaseIO.html#sWord64"><span class="hs-identifier hs-var hs-var">sWord64</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SWord64
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SWord64
</span><a href="Data.SBV.Core.Model.html#sWord64"><span class="hs-identifier hs-var">Trans.sWord64</span></a></span><span>
</span><span id="line-411"></span><span>
</span><span id="line-412"></span><span class="hs-comment">-- | Declare an unnamed 'SWord64'</span><span>
</span><span id="line-413"></span><span class="hs-comment">--</span><span>
</span><span id="line-414"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord64_'</span><span>
</span><span id="line-415"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord64_"><span class="hs-identifier hs-type">sWord64_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord64"><span class="hs-identifier hs-type">SWord64</span></a></span><span>
</span><span id="line-416"></span><span id="sWord64_"><span class="annot"><span class="annottext">sWord64_ :: Symbolic SWord64
</span><a href="Data.SBV.Client.BaseIO.html#sWord64_"><span class="hs-identifier hs-var hs-var">sWord64_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SWord64
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SWord64
</span><a href="Data.SBV.Core.Model.html#sWord64_"><span class="hs-identifier hs-var">Trans.sWord64_</span></a></span><span>
</span><span id="line-417"></span><span>
</span><span id="line-418"></span><span class="hs-comment">-- | Declare a list of 'SWord64's</span><span>
</span><span id="line-419"></span><span class="hs-comment">--</span><span>
</span><span id="line-420"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord64s'</span><span>
</span><span id="line-421"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord64s"><span class="hs-identifier hs-type">sWord64s</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord64"><span class="hs-identifier hs-type">SWord64</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-422"></span><span id="sWord64s"><span class="annot"><span class="annottext">sWord64s :: [String] -&gt; Symbolic [SWord64]
</span><a href="Data.SBV.Client.BaseIO.html#sWord64s"><span class="hs-identifier hs-var hs-var">sWord64s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SWord64]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SWord64]
</span><a href="Data.SBV.Core.Model.html#sWord64s"><span class="hs-identifier hs-var">Trans.sWord64s</span></a></span><span>
</span><span id="line-423"></span><span>
</span><span id="line-424"></span><span class="hs-comment">-- | Declare a named 'SWord'</span><span>
</span><span id="line-425"></span><span class="hs-comment">--</span><span>
</span><span id="line-426"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord'</span><span>
</span><span id="line-427"></span><span id="local-6989586621681156376"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord"><span class="hs-identifier hs-type">sWord</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KnownNat</span></span><span> </span><span class="annot"><a href="#local-6989586621681156376"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#IsNonZero"><span class="hs-identifier hs-type">IsNonZero</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156376"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156376"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-428"></span><span id="sWord"><span class="annot"><span class="annottext">sWord :: String -&gt; Symbolic (SWord n)
</span><a href="Data.SBV.Client.BaseIO.html#sWord"><span class="hs-identifier hs-var hs-var">sWord</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic (SWord n)
forall (n :: Nat) (m :: * -&gt; *).
(KnownNat n, IsNonZero n, MonadSymbolic m) =&gt;
String -&gt; m (SWord n)
</span><a href="Data.SBV.Core.Sized.html#sWord"><span class="hs-identifier hs-var">Trans.sWord</span></a></span><span>
</span><span id="line-429"></span><span>
</span><span id="line-430"></span><span class="hs-comment">-- | Declare an unnamed 'SWord'</span><span>
</span><span id="line-431"></span><span class="hs-comment">--</span><span>
</span><span id="line-432"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWord_'</span><span>
</span><span id="line-433"></span><span id="local-6989586621681156373"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWord_"><span class="hs-identifier hs-type">sWord_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KnownNat</span></span><span> </span><span class="annot"><a href="#local-6989586621681156373"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#IsNonZero"><span class="hs-identifier hs-type">IsNonZero</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156373"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156373"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-434"></span><span id="sWord_"><span class="annot"><span class="annottext">sWord_ :: Symbolic (SWord n)
</span><a href="Data.SBV.Client.BaseIO.html#sWord_"><span class="hs-identifier hs-var hs-var">sWord_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic (SWord n)
forall (n :: Nat) (m :: * -&gt; *).
(KnownNat n, IsNonZero n, MonadSymbolic m) =&gt;
m (SWord n)
</span><a href="Data.SBV.Core.Sized.html#sWord_"><span class="hs-identifier hs-var">Trans.sWord_</span></a></span><span>
</span><span id="line-435"></span><span>
</span><span id="line-436"></span><span class="hs-comment">-- | Declare a list of 'SWord8's</span><span>
</span><span id="line-437"></span><span class="hs-comment">--</span><span>
</span><span id="line-438"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sWords'</span><span>
</span><span id="line-439"></span><span id="local-6989586621681156370"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sWords"><span class="hs-identifier hs-type">sWords</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KnownNat</span></span><span> </span><span class="annot"><a href="#local-6989586621681156370"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#IsNonZero"><span class="hs-identifier hs-type">IsNonZero</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156370"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156370"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-440"></span><span id="sWords"><span class="annot"><span class="annottext">sWords :: [String] -&gt; Symbolic [SWord n]
</span><a href="Data.SBV.Client.BaseIO.html#sWords"><span class="hs-identifier hs-var hs-var">sWords</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SWord n]
forall (n :: Nat) (m :: * -&gt; *).
(KnownNat n, IsNonZero n, MonadSymbolic m) =&gt;
[String] -&gt; m [SWord n]
</span><a href="Data.SBV.Core.Sized.html#sWords"><span class="hs-identifier hs-var">Trans.sWords</span></a></span><span>
</span><span id="line-441"></span><span>
</span><span id="line-442"></span><span class="hs-comment">-- | Declare a named 'SInt8'</span><span>
</span><span id="line-443"></span><span class="hs-comment">--</span><span>
</span><span id="line-444"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt8'</span><span>
</span><span id="line-445"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt8"><span class="hs-identifier hs-type">sInt8</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt8"><span class="hs-identifier hs-type">SInt8</span></a></span><span>
</span><span id="line-446"></span><span id="sInt8"><span class="annot"><span class="annottext">sInt8 :: String -&gt; Symbolic SInt8
</span><a href="Data.SBV.Client.BaseIO.html#sInt8"><span class="hs-identifier hs-var hs-var">sInt8</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SInt8
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SInt8
</span><a href="Data.SBV.Core.Model.html#sInt8"><span class="hs-identifier hs-var">Trans.sInt8</span></a></span><span>
</span><span id="line-447"></span><span>
</span><span id="line-448"></span><span class="hs-comment">-- | Declare an unnamed 'SInt8'</span><span>
</span><span id="line-449"></span><span class="hs-comment">--</span><span>
</span><span id="line-450"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt8_'</span><span>
</span><span id="line-451"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt8_"><span class="hs-identifier hs-type">sInt8_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt8"><span class="hs-identifier hs-type">SInt8</span></a></span><span>
</span><span id="line-452"></span><span id="sInt8_"><span class="annot"><span class="annottext">sInt8_ :: Symbolic SInt8
</span><a href="Data.SBV.Client.BaseIO.html#sInt8_"><span class="hs-identifier hs-var hs-var">sInt8_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SInt8
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SInt8
</span><a href="Data.SBV.Core.Model.html#sInt8_"><span class="hs-identifier hs-var">Trans.sInt8_</span></a></span><span>
</span><span id="line-453"></span><span>
</span><span id="line-454"></span><span class="hs-comment">-- | Declare a list of 'SInt8's</span><span>
</span><span id="line-455"></span><span class="hs-comment">--</span><span>
</span><span id="line-456"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt8s'</span><span>
</span><span id="line-457"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt8s"><span class="hs-identifier hs-type">sInt8s</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt8"><span class="hs-identifier hs-type">SInt8</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-458"></span><span id="sInt8s"><span class="annot"><span class="annottext">sInt8s :: [String] -&gt; Symbolic [SInt8]
</span><a href="Data.SBV.Client.BaseIO.html#sInt8s"><span class="hs-identifier hs-var hs-var">sInt8s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SInt8]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SInt8]
</span><a href="Data.SBV.Core.Model.html#sInt8s"><span class="hs-identifier hs-var">Trans.sInt8s</span></a></span><span>
</span><span id="line-459"></span><span>
</span><span id="line-460"></span><span class="hs-comment">-- | Declare a named 'SInt16'</span><span>
</span><span id="line-461"></span><span class="hs-comment">--</span><span>
</span><span id="line-462"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt16'</span><span>
</span><span id="line-463"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt16"><span class="hs-identifier hs-type">sInt16</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt16"><span class="hs-identifier hs-type">SInt16</span></a></span><span>
</span><span id="line-464"></span><span id="sInt16"><span class="annot"><span class="annottext">sInt16 :: String -&gt; Symbolic SInt16
</span><a href="Data.SBV.Client.BaseIO.html#sInt16"><span class="hs-identifier hs-var hs-var">sInt16</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SInt16
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SInt16
</span><a href="Data.SBV.Core.Model.html#sInt16"><span class="hs-identifier hs-var">Trans.sInt16</span></a></span><span>
</span><span id="line-465"></span><span>
</span><span id="line-466"></span><span class="hs-comment">-- | Declare an unnamed 'SInt16'</span><span>
</span><span id="line-467"></span><span class="hs-comment">--</span><span>
</span><span id="line-468"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt16_'</span><span>
</span><span id="line-469"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt16_"><span class="hs-identifier hs-type">sInt16_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt16"><span class="hs-identifier hs-type">SInt16</span></a></span><span>
</span><span id="line-470"></span><span id="sInt16_"><span class="annot"><span class="annottext">sInt16_ :: Symbolic SInt16
</span><a href="Data.SBV.Client.BaseIO.html#sInt16_"><span class="hs-identifier hs-var hs-var">sInt16_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SInt16
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SInt16
</span><a href="Data.SBV.Core.Model.html#sInt16_"><span class="hs-identifier hs-var">Trans.sInt16_</span></a></span><span>
</span><span id="line-471"></span><span>
</span><span id="line-472"></span><span class="hs-comment">-- | Declare a list of 'SInt16's</span><span>
</span><span id="line-473"></span><span class="hs-comment">--</span><span>
</span><span id="line-474"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt16s'</span><span>
</span><span id="line-475"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt16s"><span class="hs-identifier hs-type">sInt16s</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt16"><span class="hs-identifier hs-type">SInt16</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-476"></span><span id="sInt16s"><span class="annot"><span class="annottext">sInt16s :: [String] -&gt; Symbolic [SInt16]
</span><a href="Data.SBV.Client.BaseIO.html#sInt16s"><span class="hs-identifier hs-var hs-var">sInt16s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SInt16]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SInt16]
</span><a href="Data.SBV.Core.Model.html#sInt16s"><span class="hs-identifier hs-var">Trans.sInt16s</span></a></span><span>
</span><span id="line-477"></span><span>
</span><span id="line-478"></span><span class="hs-comment">-- | Declare a named 'SInt32'</span><span>
</span><span id="line-479"></span><span class="hs-comment">--</span><span>
</span><span id="line-480"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt32'</span><span>
</span><span id="line-481"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt32"><span class="hs-identifier hs-type">sInt32</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt32"><span class="hs-identifier hs-type">SInt32</span></a></span><span>
</span><span id="line-482"></span><span id="sInt32"><span class="annot"><span class="annottext">sInt32 :: String -&gt; Symbolic SInt32
</span><a href="Data.SBV.Client.BaseIO.html#sInt32"><span class="hs-identifier hs-var hs-var">sInt32</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SInt32
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SInt32
</span><a href="Data.SBV.Core.Model.html#sInt32"><span class="hs-identifier hs-var">Trans.sInt32</span></a></span><span>
</span><span id="line-483"></span><span>
</span><span id="line-484"></span><span class="hs-comment">-- | Declare an unnamed 'SInt32'</span><span>
</span><span id="line-485"></span><span class="hs-comment">--</span><span>
</span><span id="line-486"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt32_'</span><span>
</span><span id="line-487"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt32_"><span class="hs-identifier hs-type">sInt32_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt32"><span class="hs-identifier hs-type">SInt32</span></a></span><span>
</span><span id="line-488"></span><span id="sInt32_"><span class="annot"><span class="annottext">sInt32_ :: Symbolic SInt32
</span><a href="Data.SBV.Client.BaseIO.html#sInt32_"><span class="hs-identifier hs-var hs-var">sInt32_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SInt32
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SInt32
</span><a href="Data.SBV.Core.Model.html#sInt32_"><span class="hs-identifier hs-var">Trans.sInt32_</span></a></span><span>
</span><span id="line-489"></span><span>
</span><span id="line-490"></span><span class="hs-comment">-- | Declare a list of 'SInt32's</span><span>
</span><span id="line-491"></span><span class="hs-comment">--</span><span>
</span><span id="line-492"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt32s'</span><span>
</span><span id="line-493"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt32s"><span class="hs-identifier hs-type">sInt32s</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt32"><span class="hs-identifier hs-type">SInt32</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-494"></span><span id="sInt32s"><span class="annot"><span class="annottext">sInt32s :: [String] -&gt; Symbolic [SInt32]
</span><a href="Data.SBV.Client.BaseIO.html#sInt32s"><span class="hs-identifier hs-var hs-var">sInt32s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SInt32]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SInt32]
</span><a href="Data.SBV.Core.Model.html#sInt32s"><span class="hs-identifier hs-var">Trans.sInt32s</span></a></span><span>
</span><span id="line-495"></span><span>
</span><span id="line-496"></span><span class="hs-comment">-- | Declare a named 'SInt64'</span><span>
</span><span id="line-497"></span><span class="hs-comment">--</span><span>
</span><span id="line-498"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt64'</span><span>
</span><span id="line-499"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt64"><span class="hs-identifier hs-type">sInt64</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt64"><span class="hs-identifier hs-type">SInt64</span></a></span><span>
</span><span id="line-500"></span><span id="sInt64"><span class="annot"><span class="annottext">sInt64 :: String -&gt; Symbolic SInt64
</span><a href="Data.SBV.Client.BaseIO.html#sInt64"><span class="hs-identifier hs-var hs-var">sInt64</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SInt64
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SInt64
</span><a href="Data.SBV.Core.Model.html#sInt64"><span class="hs-identifier hs-var">Trans.sInt64</span></a></span><span>
</span><span id="line-501"></span><span>
</span><span id="line-502"></span><span class="hs-comment">-- | Declare an unnamed 'SInt64'</span><span>
</span><span id="line-503"></span><span class="hs-comment">--</span><span>
</span><span id="line-504"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt64_'</span><span>
</span><span id="line-505"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt64_"><span class="hs-identifier hs-type">sInt64_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt64"><span class="hs-identifier hs-type">SInt64</span></a></span><span>
</span><span id="line-506"></span><span id="sInt64_"><span class="annot"><span class="annottext">sInt64_ :: Symbolic SInt64
</span><a href="Data.SBV.Client.BaseIO.html#sInt64_"><span class="hs-identifier hs-var hs-var">sInt64_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SInt64
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SInt64
</span><a href="Data.SBV.Core.Model.html#sInt64_"><span class="hs-identifier hs-var">Trans.sInt64_</span></a></span><span>
</span><span id="line-507"></span><span>
</span><span id="line-508"></span><span class="hs-comment">-- | Declare a list of 'SInt64's</span><span>
</span><span id="line-509"></span><span class="hs-comment">--</span><span>
</span><span id="line-510"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt64s'</span><span>
</span><span id="line-511"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt64s"><span class="hs-identifier hs-type">sInt64s</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt64"><span class="hs-identifier hs-type">SInt64</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-512"></span><span id="sInt64s"><span class="annot"><span class="annottext">sInt64s :: [String] -&gt; Symbolic [SInt64]
</span><a href="Data.SBV.Client.BaseIO.html#sInt64s"><span class="hs-identifier hs-var hs-var">sInt64s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SInt64]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SInt64]
</span><a href="Data.SBV.Core.Model.html#sInt64s"><span class="hs-identifier hs-var">Trans.sInt64s</span></a></span><span>
</span><span id="line-513"></span><span>
</span><span id="line-514"></span><span class="hs-comment">-- | Declare a named 'SInt'</span><span>
</span><span id="line-515"></span><span class="hs-comment">--</span><span>
</span><span id="line-516"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt'</span><span>
</span><span id="line-517"></span><span id="local-6989586621681156343"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt"><span class="hs-identifier hs-type">sInt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KnownNat</span></span><span> </span><span class="annot"><a href="#local-6989586621681156343"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#IsNonZero"><span class="hs-identifier hs-type">IsNonZero</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156343"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156343"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-518"></span><span id="sInt"><span class="annot"><span class="annottext">sInt :: String -&gt; Symbolic (SInt n)
</span><a href="Data.SBV.Client.BaseIO.html#sInt"><span class="hs-identifier hs-var hs-var">sInt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic (SInt n)
forall (n :: Nat) (m :: * -&gt; *).
(KnownNat n, IsNonZero n, MonadSymbolic m) =&gt;
String -&gt; m (SInt n)
</span><a href="Data.SBV.Core.Sized.html#sInt"><span class="hs-identifier hs-var">Trans.sInt</span></a></span><span>
</span><span id="line-519"></span><span>
</span><span id="line-520"></span><span class="hs-comment">-- | Declare an unnamed 'SInt'</span><span>
</span><span id="line-521"></span><span class="hs-comment">--</span><span>
</span><span id="line-522"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInt_'</span><span>
</span><span id="line-523"></span><span id="local-6989586621681156340"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInt_"><span class="hs-identifier hs-type">sInt_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KnownNat</span></span><span> </span><span class="annot"><a href="#local-6989586621681156340"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#IsNonZero"><span class="hs-identifier hs-type">IsNonZero</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156340"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156340"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-524"></span><span id="sInt_"><span class="annot"><span class="annottext">sInt_ :: Symbolic (SInt n)
</span><a href="Data.SBV.Client.BaseIO.html#sInt_"><span class="hs-identifier hs-var hs-var">sInt_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic (SInt n)
forall (n :: Nat) (m :: * -&gt; *).
(KnownNat n, IsNonZero n, MonadSymbolic m) =&gt;
m (SInt n)
</span><a href="Data.SBV.Core.Sized.html#sInt_"><span class="hs-identifier hs-var">Trans.sInt_</span></a></span><span>
</span><span id="line-525"></span><span>
</span><span id="line-526"></span><span class="hs-comment">-- | Declare a list of 'SInt's</span><span>
</span><span id="line-527"></span><span class="hs-comment">--</span><span>
</span><span id="line-528"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInts'</span><span>
</span><span id="line-529"></span><span id="local-6989586621681156337"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInts"><span class="hs-identifier hs-type">sInts</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KnownNat</span></span><span> </span><span class="annot"><a href="#local-6989586621681156337"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#IsNonZero"><span class="hs-identifier hs-type">IsNonZero</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156337"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156337"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-530"></span><span id="sInts"><span class="annot"><span class="annottext">sInts :: [String] -&gt; Symbolic [SInt n]
</span><a href="Data.SBV.Client.BaseIO.html#sInts"><span class="hs-identifier hs-var hs-var">sInts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SInt n]
forall (n :: Nat) (m :: * -&gt; *).
(KnownNat n, IsNonZero n, MonadSymbolic m) =&gt;
[String] -&gt; m [SInt n]
</span><a href="Data.SBV.Core.Sized.html#sInts"><span class="hs-identifier hs-var">Trans.sInts</span></a></span><span>
</span><span id="line-531"></span><span>
</span><span id="line-532"></span><span class="hs-comment">-- | Declare a named 'SInteger'</span><span>
</span><span id="line-533"></span><span class="hs-comment">--</span><span>
</span><span id="line-534"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInteger'</span><span>
</span><span id="line-535"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInteger"><span class="hs-identifier hs-type">sInteger</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInteger"><span class="hs-identifier hs-type">SInteger</span></a></span><span>
</span><span id="line-536"></span><span id="sInteger"><span class="annot"><span class="annottext">sInteger :: String -&gt; Symbolic SInteger
</span><a href="Data.SBV.Client.BaseIO.html#sInteger"><span class="hs-identifier hs-var hs-var">sInteger</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SInteger
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SInteger
</span><a href="Data.SBV.Core.Model.html#sInteger"><span class="hs-identifier hs-var">Trans.sInteger</span></a></span><span>
</span><span id="line-537"></span><span>
</span><span id="line-538"></span><span class="hs-comment">-- | Declare an unnamed 'SInteger'</span><span>
</span><span id="line-539"></span><span class="hs-comment">--</span><span>
</span><span id="line-540"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sInteger_'</span><span>
</span><span id="line-541"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sInteger_"><span class="hs-identifier hs-type">sInteger_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInteger"><span class="hs-identifier hs-type">SInteger</span></a></span><span>
</span><span id="line-542"></span><span id="sInteger_"><span class="annot"><span class="annottext">sInteger_ :: Symbolic SInteger
</span><a href="Data.SBV.Client.BaseIO.html#sInteger_"><span class="hs-identifier hs-var hs-var">sInteger_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SInteger
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SInteger
</span><a href="Data.SBV.Core.Model.html#sInteger_"><span class="hs-identifier hs-var">Trans.sInteger_</span></a></span><span>
</span><span id="line-543"></span><span>
</span><span id="line-544"></span><span class="hs-comment">-- | Declare a list of 'SInteger's</span><span>
</span><span id="line-545"></span><span class="hs-comment">--</span><span>
</span><span id="line-546"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sIntegers'</span><span>
</span><span id="line-547"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sIntegers"><span class="hs-identifier hs-type">sIntegers</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SInteger"><span class="hs-identifier hs-type">SInteger</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-548"></span><span id="sIntegers"><span class="annot"><span class="annottext">sIntegers :: [String] -&gt; Symbolic [SInteger]
</span><a href="Data.SBV.Client.BaseIO.html#sIntegers"><span class="hs-identifier hs-var hs-var">sIntegers</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SInteger]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SInteger]
</span><a href="Data.SBV.Core.Model.html#sIntegers"><span class="hs-identifier hs-var">Trans.sIntegers</span></a></span><span>
</span><span id="line-549"></span><span>
</span><span id="line-550"></span><span class="hs-comment">-- | Declare a named 'SReal'</span><span>
</span><span id="line-551"></span><span class="hs-comment">--</span><span>
</span><span id="line-552"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sReal'</span><span>
</span><span id="line-553"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sReal"><span class="hs-identifier hs-type">sReal</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SReal"><span class="hs-identifier hs-type">SReal</span></a></span><span>
</span><span id="line-554"></span><span id="sReal"><span class="annot"><span class="annottext">sReal :: String -&gt; Symbolic SReal
</span><a href="Data.SBV.Client.BaseIO.html#sReal"><span class="hs-identifier hs-var hs-var">sReal</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SReal
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SReal
</span><a href="Data.SBV.Core.Model.html#sReal"><span class="hs-identifier hs-var">Trans.sReal</span></a></span><span>
</span><span id="line-555"></span><span>
</span><span id="line-556"></span><span class="hs-comment">-- | Declare an unnamed 'SReal'</span><span>
</span><span id="line-557"></span><span class="hs-comment">--</span><span>
</span><span id="line-558"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sReal_'</span><span>
</span><span id="line-559"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sReal_"><span class="hs-identifier hs-type">sReal_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SReal"><span class="hs-identifier hs-type">SReal</span></a></span><span>
</span><span id="line-560"></span><span id="sReal_"><span class="annot"><span class="annottext">sReal_ :: Symbolic SReal
</span><a href="Data.SBV.Client.BaseIO.html#sReal_"><span class="hs-identifier hs-var hs-var">sReal_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SReal
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SReal
</span><a href="Data.SBV.Core.Model.html#sReal_"><span class="hs-identifier hs-var">Trans.sReal_</span></a></span><span>
</span><span id="line-561"></span><span>
</span><span id="line-562"></span><span class="hs-comment">-- | Declare a list of 'SReal's</span><span>
</span><span id="line-563"></span><span class="hs-comment">--</span><span>
</span><span id="line-564"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sReals'</span><span>
</span><span id="line-565"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sReals"><span class="hs-identifier hs-type">sReals</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SReal"><span class="hs-identifier hs-type">SReal</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-566"></span><span id="sReals"><span class="annot"><span class="annottext">sReals :: [String] -&gt; Symbolic [SReal]
</span><a href="Data.SBV.Client.BaseIO.html#sReals"><span class="hs-identifier hs-var hs-var">sReals</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SReal]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SReal]
</span><a href="Data.SBV.Core.Model.html#sReals"><span class="hs-identifier hs-var">Trans.sReals</span></a></span><span>
</span><span id="line-567"></span><span>
</span><span id="line-568"></span><span class="hs-comment">-- | Declare a named 'SFloat'</span><span>
</span><span id="line-569"></span><span class="hs-comment">--</span><span>
</span><span id="line-570"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sFloat'</span><span>
</span><span id="line-571"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sFloat"><span class="hs-identifier hs-type">sFloat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SFloat"><span class="hs-identifier hs-type">SFloat</span></a></span><span>
</span><span id="line-572"></span><span id="sFloat"><span class="annot"><span class="annottext">sFloat :: String -&gt; Symbolic SFloat
</span><a href="Data.SBV.Client.BaseIO.html#sFloat"><span class="hs-identifier hs-var hs-var">sFloat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SFloat
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SFloat
</span><a href="Data.SBV.Core.Model.html#sFloat"><span class="hs-identifier hs-var">Trans.sFloat</span></a></span><span>
</span><span id="line-573"></span><span>
</span><span id="line-574"></span><span class="hs-comment">-- | Declare an unnamed 'SFloat'</span><span>
</span><span id="line-575"></span><span class="hs-comment">--</span><span>
</span><span id="line-576"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sFloat_'</span><span>
</span><span id="line-577"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sFloat_"><span class="hs-identifier hs-type">sFloat_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SFloat"><span class="hs-identifier hs-type">SFloat</span></a></span><span>
</span><span id="line-578"></span><span id="sFloat_"><span class="annot"><span class="annottext">sFloat_ :: Symbolic SFloat
</span><a href="Data.SBV.Client.BaseIO.html#sFloat_"><span class="hs-identifier hs-var hs-var">sFloat_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SFloat
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SFloat
</span><a href="Data.SBV.Core.Model.html#sFloat_"><span class="hs-identifier hs-var">Trans.sFloat_</span></a></span><span>
</span><span id="line-579"></span><span>
</span><span id="line-580"></span><span class="hs-comment">-- | Declare a list of 'SFloat's</span><span>
</span><span id="line-581"></span><span class="hs-comment">--</span><span>
</span><span id="line-582"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sFloats'</span><span>
</span><span id="line-583"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sFloats"><span class="hs-identifier hs-type">sFloats</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SFloat"><span class="hs-identifier hs-type">SFloat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-584"></span><span id="sFloats"><span class="annot"><span class="annottext">sFloats :: [String] -&gt; Symbolic [SFloat]
</span><a href="Data.SBV.Client.BaseIO.html#sFloats"><span class="hs-identifier hs-var hs-var">sFloats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SFloat]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SFloat]
</span><a href="Data.SBV.Core.Model.html#sFloats"><span class="hs-identifier hs-var">Trans.sFloats</span></a></span><span>
</span><span id="line-585"></span><span>
</span><span id="line-586"></span><span class="hs-comment">-- | Declare a named 'SDouble'</span><span>
</span><span id="line-587"></span><span class="hs-comment">--</span><span>
</span><span id="line-588"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sDouble'</span><span>
</span><span id="line-589"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sDouble"><span class="hs-identifier hs-type">sDouble</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SDouble"><span class="hs-identifier hs-type">SDouble</span></a></span><span>
</span><span id="line-590"></span><span id="sDouble"><span class="annot"><span class="annottext">sDouble :: String -&gt; Symbolic SDouble
</span><a href="Data.SBV.Client.BaseIO.html#sDouble"><span class="hs-identifier hs-var hs-var">sDouble</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SDouble
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SDouble
</span><a href="Data.SBV.Core.Model.html#sDouble"><span class="hs-identifier hs-var">Trans.sDouble</span></a></span><span>
</span><span id="line-591"></span><span>
</span><span id="line-592"></span><span class="hs-comment">-- | Declare an unnamed 'SDouble'</span><span>
</span><span id="line-593"></span><span class="hs-comment">--</span><span>
</span><span id="line-594"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sDouble_'</span><span>
</span><span id="line-595"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sDouble_"><span class="hs-identifier hs-type">sDouble_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SDouble"><span class="hs-identifier hs-type">SDouble</span></a></span><span>
</span><span id="line-596"></span><span id="sDouble_"><span class="annot"><span class="annottext">sDouble_ :: Symbolic SDouble
</span><a href="Data.SBV.Client.BaseIO.html#sDouble_"><span class="hs-identifier hs-var hs-var">sDouble_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SDouble
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SDouble
</span><a href="Data.SBV.Core.Model.html#sDouble_"><span class="hs-identifier hs-var">Trans.sDouble_</span></a></span><span>
</span><span id="line-597"></span><span>
</span><span id="line-598"></span><span class="hs-comment">-- | Declare a list of 'SDouble's</span><span>
</span><span id="line-599"></span><span class="hs-comment">--</span><span>
</span><span id="line-600"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sDoubles'</span><span>
</span><span id="line-601"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sDoubles"><span class="hs-identifier hs-type">sDoubles</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SDouble"><span class="hs-identifier hs-type">SDouble</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-602"></span><span id="sDoubles"><span class="annot"><span class="annottext">sDoubles :: [String] -&gt; Symbolic [SDouble]
</span><a href="Data.SBV.Client.BaseIO.html#sDoubles"><span class="hs-identifier hs-var hs-var">sDoubles</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SDouble]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SDouble]
</span><a href="Data.SBV.Core.Model.html#sDoubles"><span class="hs-identifier hs-var">Trans.sDoubles</span></a></span><span>
</span><span id="line-603"></span><span>
</span><span id="line-604"></span><span class="hs-comment">-- | Declare a named 'SChar'</span><span>
</span><span id="line-605"></span><span class="hs-comment">--</span><span>
</span><span id="line-606"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sChar'</span><span>
</span><span id="line-607"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sChar"><span class="hs-identifier hs-type">sChar</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SChar"><span class="hs-identifier hs-type">SChar</span></a></span><span>
</span><span id="line-608"></span><span id="sChar"><span class="annot"><span class="annottext">sChar :: String -&gt; Symbolic SChar
</span><a href="Data.SBV.Client.BaseIO.html#sChar"><span class="hs-identifier hs-var hs-var">sChar</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SChar
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SChar
</span><a href="Data.SBV.Core.Model.html#sChar"><span class="hs-identifier hs-var">Trans.sChar</span></a></span><span>
</span><span id="line-609"></span><span>
</span><span id="line-610"></span><span class="hs-comment">-- | Declare an unnamed 'SChar'</span><span>
</span><span id="line-611"></span><span class="hs-comment">--</span><span>
</span><span id="line-612"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sChar_'</span><span>
</span><span id="line-613"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sChar_"><span class="hs-identifier hs-type">sChar_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SChar"><span class="hs-identifier hs-type">SChar</span></a></span><span>
</span><span id="line-614"></span><span id="sChar_"><span class="annot"><span class="annottext">sChar_ :: Symbolic SChar
</span><a href="Data.SBV.Client.BaseIO.html#sChar_"><span class="hs-identifier hs-var hs-var">sChar_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SChar
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SChar
</span><a href="Data.SBV.Core.Model.html#sChar_"><span class="hs-identifier hs-var">Trans.sChar_</span></a></span><span>
</span><span id="line-615"></span><span>
</span><span id="line-616"></span><span class="hs-comment">-- | Declare a list of 'SChar's</span><span>
</span><span id="line-617"></span><span class="hs-comment">--</span><span>
</span><span id="line-618"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sChars'</span><span>
</span><span id="line-619"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sChars"><span class="hs-identifier hs-type">sChars</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SChar"><span class="hs-identifier hs-type">SChar</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-620"></span><span id="sChars"><span class="annot"><span class="annottext">sChars :: [String] -&gt; Symbolic [SChar]
</span><a href="Data.SBV.Client.BaseIO.html#sChars"><span class="hs-identifier hs-var hs-var">sChars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SChar]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SChar]
</span><a href="Data.SBV.Core.Model.html#sChars"><span class="hs-identifier hs-var">Trans.sChars</span></a></span><span>
</span><span id="line-621"></span><span>
</span><span id="line-622"></span><span class="hs-comment">-- | Declare a named 'SString'</span><span>
</span><span id="line-623"></span><span class="hs-comment">--</span><span>
</span><span id="line-624"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sString'</span><span>
</span><span id="line-625"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sString"><span class="hs-identifier hs-type">sString</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SString"><span class="hs-identifier hs-type">SString</span></a></span><span>
</span><span id="line-626"></span><span id="sString"><span class="annot"><span class="annottext">sString :: String -&gt; Symbolic SString
</span><a href="Data.SBV.Client.BaseIO.html#sString"><span class="hs-identifier hs-var hs-var">sString</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic SString
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; m SString
</span><a href="Data.SBV.Core.Model.html#sString"><span class="hs-identifier hs-var">Trans.sString</span></a></span><span>
</span><span id="line-627"></span><span>
</span><span id="line-628"></span><span class="hs-comment">-- | Declare an unnamed 'SString'</span><span>
</span><span id="line-629"></span><span class="hs-comment">--</span><span>
</span><span id="line-630"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sString_'</span><span>
</span><span id="line-631"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sString_"><span class="hs-identifier hs-type">sString_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SString"><span class="hs-identifier hs-type">SString</span></a></span><span>
</span><span id="line-632"></span><span id="sString_"><span class="annot"><span class="annottext">sString_ :: Symbolic SString
</span><a href="Data.SBV.Client.BaseIO.html#sString_"><span class="hs-identifier hs-var hs-var">sString_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic SString
forall (m :: * -&gt; *). MonadSymbolic m =&gt; m SString
</span><a href="Data.SBV.Core.Model.html#sString_"><span class="hs-identifier hs-var">Trans.sString_</span></a></span><span>
</span><span id="line-633"></span><span>
</span><span id="line-634"></span><span class="hs-comment">-- | Declare a list of 'SString's</span><span>
</span><span id="line-635"></span><span class="hs-comment">--</span><span>
</span><span id="line-636"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sStrings'</span><span>
</span><span id="line-637"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sStrings"><span class="hs-identifier hs-type">sStrings</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SString"><span class="hs-identifier hs-type">SString</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-638"></span><span id="sStrings"><span class="annot"><span class="annottext">sStrings :: [String] -&gt; Symbolic [SString]
</span><a href="Data.SBV.Client.BaseIO.html#sStrings"><span class="hs-identifier hs-var hs-var">sStrings</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SString]
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [String] -&gt; m [SString]
</span><a href="Data.SBV.Core.Model.html#sStrings"><span class="hs-identifier hs-var">Trans.sStrings</span></a></span><span>
</span><span id="line-639"></span><span>
</span><span id="line-640"></span><span class="hs-comment">-- | Declare a named 'SList'</span><span>
</span><span id="line-641"></span><span class="hs-comment">--</span><span>
</span><span id="line-642"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sList'</span><span>
</span><span id="line-643"></span><span id="local-6989586621681156298"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sList"><span class="hs-identifier hs-type">sList</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156298"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SList"><span class="hs-identifier hs-type">SList</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156298"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-644"></span><span id="sList"><span class="annot"><span class="annottext">sList :: String -&gt; Symbolic (SList a)
</span><a href="Data.SBV.Client.BaseIO.html#sList"><span class="hs-identifier hs-var hs-var">sList</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic (SList a)
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
String -&gt; m (SList a)
</span><a href="Data.SBV.Core.Model.html#sList"><span class="hs-identifier hs-var">Trans.sList</span></a></span><span>
</span><span id="line-645"></span><span>
</span><span id="line-646"></span><span class="hs-comment">-- | Declare an unnamed 'SList'</span><span>
</span><span id="line-647"></span><span class="hs-comment">--</span><span>
</span><span id="line-648"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sList_'</span><span>
</span><span id="line-649"></span><span id="local-6989586621681156295"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sList_"><span class="hs-identifier hs-type">sList_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156295"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SList"><span class="hs-identifier hs-type">SList</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156295"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-650"></span><span id="sList_"><span class="annot"><span class="annottext">sList_ :: Symbolic (SList a)
</span><a href="Data.SBV.Client.BaseIO.html#sList_"><span class="hs-identifier hs-var hs-var">sList_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic (SList a)
forall a (m :: * -&gt; *). (SymVal a, MonadSymbolic m) =&gt; m (SList a)
</span><a href="Data.SBV.Core.Model.html#sList_"><span class="hs-identifier hs-var">Trans.sList_</span></a></span><span>
</span><span id="line-651"></span><span>
</span><span id="line-652"></span><span class="hs-comment">-- | Declare a list of 'SList's</span><span>
</span><span id="line-653"></span><span class="hs-comment">--</span><span>
</span><span id="line-654"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sLists'</span><span>
</span><span id="line-655"></span><span id="local-6989586621681156292"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sLists"><span class="hs-identifier hs-type">sLists</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156292"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SList"><span class="hs-identifier hs-type">SList</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156292"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-656"></span><span id="sLists"><span class="annot"><span class="annottext">sLists :: [String] -&gt; Symbolic [SList a]
</span><a href="Data.SBV.Client.BaseIO.html#sLists"><span class="hs-identifier hs-var hs-var">sLists</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SList a]
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
[String] -&gt; m [SList a]
</span><a href="Data.SBV.Core.Model.html#sLists"><span class="hs-identifier hs-var">Trans.sLists</span></a></span><span>
</span><span id="line-657"></span><span>
</span><span id="line-658"></span><span class="hs-comment">-- | Declare a named tuple.</span><span>
</span><span id="line-659"></span><span class="hs-comment">--</span><span>
</span><span id="line-660"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sTuple'</span><span>
</span><span id="line-661"></span><span id="local-6989586621681156289"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sTuple"><span class="hs-identifier hs-type">sTuple</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Model.html#SymTuple"><span class="hs-identifier hs-type">SymTuple</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156289"><span class="hs-identifier hs-type">tup</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156289"><span class="hs-identifier hs-type">tup</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156289"><span class="hs-identifier hs-type">tup</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-662"></span><span id="sTuple"><span class="annot"><span class="annottext">sTuple :: String -&gt; Symbolic (SBV tup)
</span><a href="Data.SBV.Client.BaseIO.html#sTuple"><span class="hs-identifier hs-var hs-var">sTuple</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic (SBV tup)
forall tup (m :: * -&gt; *).
(SymTuple tup, SymVal tup, MonadSymbolic m) =&gt;
String -&gt; m (SBV tup)
</span><a href="Data.SBV.Core.Model.html#sTuple"><span class="hs-identifier hs-var">Trans.sTuple</span></a></span><span>
</span><span id="line-663"></span><span>
</span><span id="line-664"></span><span class="hs-comment">-- | Declare an unnamed tuple.</span><span>
</span><span id="line-665"></span><span class="hs-comment">--</span><span>
</span><span id="line-666"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sTuple_'</span><span>
</span><span id="line-667"></span><span id="local-6989586621681156286"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sTuple_"><span class="hs-identifier hs-type">sTuple_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Model.html#SymTuple"><span class="hs-identifier hs-type">SymTuple</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156286"><span class="hs-identifier hs-type">tup</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156286"><span class="hs-identifier hs-type">tup</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156286"><span class="hs-identifier hs-type">tup</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-668"></span><span id="sTuple_"><span class="annot"><span class="annottext">sTuple_ :: Symbolic (SBV tup)
</span><a href="Data.SBV.Client.BaseIO.html#sTuple_"><span class="hs-identifier hs-var hs-var">sTuple_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic (SBV tup)
forall tup (m :: * -&gt; *).
(SymTuple tup, SymVal tup, MonadSymbolic m) =&gt;
m (SBV tup)
</span><a href="Data.SBV.Core.Model.html#sTuple_"><span class="hs-identifier hs-var">Trans.sTuple_</span></a></span><span>
</span><span id="line-669"></span><span>
</span><span id="line-670"></span><span class="hs-comment">-- | Declare a list of tuples.</span><span>
</span><span id="line-671"></span><span class="hs-comment">--</span><span>
</span><span id="line-672"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sTuples'</span><span>
</span><span id="line-673"></span><span id="local-6989586621681156283"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sTuples"><span class="hs-identifier hs-type">sTuples</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Model.html#SymTuple"><span class="hs-identifier hs-type">SymTuple</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156283"><span class="hs-identifier hs-type">tup</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156283"><span class="hs-identifier hs-type">tup</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156283"><span class="hs-identifier hs-type">tup</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-674"></span><span id="sTuples"><span class="annot"><span class="annottext">sTuples :: [String] -&gt; Symbolic [SBV tup]
</span><a href="Data.SBV.Client.BaseIO.html#sTuples"><span class="hs-identifier hs-var hs-var">sTuples</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SBV tup]
forall tup (m :: * -&gt; *).
(SymTuple tup, SymVal tup, MonadSymbolic m) =&gt;
[String] -&gt; m [SBV tup]
</span><a href="Data.SBV.Core.Model.html#sTuples"><span class="hs-identifier hs-var">Trans.sTuples</span></a></span><span>
</span><span id="line-675"></span><span>
</span><span id="line-676"></span><span class="hs-comment">-- | Declare a named 'Data.SBV.SEither'.</span><span>
</span><span id="line-677"></span><span class="hs-comment">--</span><span>
</span><span id="line-678"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sEither'</span><span>
</span><span id="line-679"></span><span id="local-6989586621681156279"><span id="local-6989586621681156280"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sEither"><span class="hs-identifier hs-type">sEither</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156280"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156279"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SEither"><span class="hs-identifier hs-type">SEither</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156280"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156279"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-680"></span><span id="sEither"><span class="annot"><span class="annottext">sEither :: String -&gt; Symbolic (SEither a b)
</span><a href="Data.SBV.Client.BaseIO.html#sEither"><span class="hs-identifier hs-var hs-var">sEither</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic (SEither a b)
forall a b (m :: * -&gt; *).
(SymVal a, SymVal b, MonadSymbolic m) =&gt;
String -&gt; m (SEither a b)
</span><a href="Data.SBV.Core.Model.html#sEither"><span class="hs-identifier hs-var">Trans.sEither</span></a></span><span>
</span><span id="line-681"></span><span>
</span><span id="line-682"></span><span class="hs-comment">-- | Declare an unnamed 'Data.SBV.SEither'.</span><span>
</span><span id="line-683"></span><span class="hs-comment">--</span><span>
</span><span id="line-684"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sEither_'</span><span>
</span><span id="line-685"></span><span id="local-6989586621681156275"><span id="local-6989586621681156276"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sEither_"><span class="hs-identifier hs-type">sEither_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156276"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156275"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SEither"><span class="hs-identifier hs-type">SEither</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156276"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156275"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-686"></span><span id="sEither_"><span class="annot"><span class="annottext">sEither_ :: Symbolic (SEither a b)
</span><a href="Data.SBV.Client.BaseIO.html#sEither_"><span class="hs-identifier hs-var hs-var">sEither_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic (SEither a b)
forall a b (m :: * -&gt; *).
(SymVal a, SymVal b, MonadSymbolic m) =&gt;
m (SEither a b)
</span><a href="Data.SBV.Core.Model.html#sEither_"><span class="hs-identifier hs-var">Trans.sEither_</span></a></span><span>
</span><span id="line-687"></span><span>
</span><span id="line-688"></span><span class="hs-comment">-- | Declare a list of 'Data.SBV.SEither' values.</span><span>
</span><span id="line-689"></span><span class="hs-comment">--</span><span>
</span><span id="line-690"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sEithers'</span><span>
</span><span id="line-691"></span><span id="local-6989586621681156271"><span id="local-6989586621681156272"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sEithers"><span class="hs-identifier hs-type">sEithers</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156272"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156271"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SEither"><span class="hs-identifier hs-type">SEither</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156272"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156271"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span></span></span><span>
</span><span id="line-692"></span><span id="sEithers"><span class="annot"><span class="annottext">sEithers :: [String] -&gt; Symbolic [SEither a b]
</span><a href="Data.SBV.Client.BaseIO.html#sEithers"><span class="hs-identifier hs-var hs-var">sEithers</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SEither a b]
forall a b (m :: * -&gt; *).
(SymVal a, SymVal b, MonadSymbolic m) =&gt;
[String] -&gt; m [SEither a b]
</span><a href="Data.SBV.Core.Model.html#sEithers"><span class="hs-identifier hs-var">Trans.sEithers</span></a></span><span>
</span><span id="line-693"></span><span>
</span><span id="line-694"></span><span class="hs-comment">-- | Declare a named 'Data.SBV.SMaybe'.</span><span>
</span><span id="line-695"></span><span class="hs-comment">--</span><span>
</span><span id="line-696"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sMaybe'</span><span>
</span><span id="line-697"></span><span id="local-6989586621681156268"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sMaybe"><span class="hs-identifier hs-type">sMaybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156268"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SMaybe"><span class="hs-identifier hs-type">SMaybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156268"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-698"></span><span id="sMaybe"><span class="annot"><span class="annottext">sMaybe :: String -&gt; Symbolic (SMaybe a)
</span><a href="Data.SBV.Client.BaseIO.html#sMaybe"><span class="hs-identifier hs-var hs-var">sMaybe</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic (SMaybe a)
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
String -&gt; m (SMaybe a)
</span><a href="Data.SBV.Core.Model.html#sMaybe"><span class="hs-identifier hs-var">Trans.sMaybe</span></a></span><span>
</span><span id="line-699"></span><span>
</span><span id="line-700"></span><span class="hs-comment">-- | Declare an unnamed 'Data.SBV.SMaybe'.</span><span>
</span><span id="line-701"></span><span class="hs-comment">--</span><span>
</span><span id="line-702"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sMaybe_'</span><span>
</span><span id="line-703"></span><span id="local-6989586621681156265"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sMaybe_"><span class="hs-identifier hs-type">sMaybe_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156265"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SMaybe"><span class="hs-identifier hs-type">SMaybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156265"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-704"></span><span id="sMaybe_"><span class="annot"><span class="annottext">sMaybe_ :: Symbolic (SMaybe a)
</span><a href="Data.SBV.Client.BaseIO.html#sMaybe_"><span class="hs-identifier hs-var hs-var">sMaybe_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic (SMaybe a)
forall a (m :: * -&gt; *). (SymVal a, MonadSymbolic m) =&gt; m (SMaybe a)
</span><a href="Data.SBV.Core.Model.html#sMaybe_"><span class="hs-identifier hs-var">Trans.sMaybe_</span></a></span><span>
</span><span id="line-705"></span><span>
</span><span id="line-706"></span><span class="hs-comment">-- | Declare a list of 'Data.SBV.SMaybe' values.</span><span>
</span><span id="line-707"></span><span class="hs-comment">--</span><span>
</span><span id="line-708"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sMaybes'</span><span>
</span><span id="line-709"></span><span id="local-6989586621681156262"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sMaybes"><span class="hs-identifier hs-type">sMaybes</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156262"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SMaybe"><span class="hs-identifier hs-type">SMaybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156262"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-710"></span><span id="sMaybes"><span class="annot"><span class="annottext">sMaybes :: [String] -&gt; Symbolic [SMaybe a]
</span><a href="Data.SBV.Client.BaseIO.html#sMaybes"><span class="hs-identifier hs-var hs-var">sMaybes</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SMaybe a]
forall a (m :: * -&gt; *).
(SymVal a, MonadSymbolic m) =&gt;
[String] -&gt; m [SMaybe a]
</span><a href="Data.SBV.Core.Model.html#sMaybes"><span class="hs-identifier hs-var">Trans.sMaybes</span></a></span><span>
</span><span id="line-711"></span><span>
</span><span id="line-712"></span><span class="hs-comment">-- | Declare a named 'Data.SBV.SSet'.</span><span>
</span><span id="line-713"></span><span class="hs-comment">--</span><span>
</span><span id="line-714"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sSet'</span><span>
</span><span id="line-715"></span><span id="local-6989586621681156259"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sSet"><span class="hs-identifier hs-type">sSet</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621681156259"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156259"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SSet"><span class="hs-identifier hs-type">SSet</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156259"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-716"></span><span id="sSet"><span class="annot"><span class="annottext">sSet :: String -&gt; Symbolic (SSet a)
</span><a href="Data.SBV.Client.BaseIO.html#sSet"><span class="hs-identifier hs-var hs-var">sSet</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Symbolic (SSet a)
forall a (m :: * -&gt; *).
(Ord a, SymVal a, MonadSymbolic m) =&gt;
String -&gt; m (SSet a)
</span><a href="Data.SBV.Core.Model.html#sSet"><span class="hs-identifier hs-var">Trans.sSet</span></a></span><span>
</span><span id="line-717"></span><span>
</span><span id="line-718"></span><span class="hs-comment">-- | Declare an unnamed 'Data.SBV.SSet'.</span><span>
</span><span id="line-719"></span><span class="hs-comment">--</span><span>
</span><span id="line-720"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sSet_'</span><span>
</span><span id="line-721"></span><span id="local-6989586621681156256"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sSet_"><span class="hs-identifier hs-type">sSet_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621681156256"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156256"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Data.html#SSet"><span class="hs-identifier hs-type">SSet</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156256"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-722"></span><span id="sSet_"><span class="annot"><span class="annottext">sSet_ :: Symbolic (SSet a)
</span><a href="Data.SBV.Client.BaseIO.html#sSet_"><span class="hs-identifier hs-var hs-var">sSet_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbolic (SSet a)
forall a (m :: * -&gt; *).
(Ord a, SymVal a, MonadSymbolic m) =&gt;
m (SSet a)
</span><a href="Data.SBV.Core.Model.html#sSet_"><span class="hs-identifier hs-var">Trans.sSet_</span></a></span><span>
</span><span id="line-723"></span><span>
</span><span id="line-724"></span><span class="hs-comment">-- | Declare a list of 'Data.SBV.SSet' values.</span><span>
</span><span id="line-725"></span><span class="hs-comment">--</span><span>
</span><span id="line-726"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.sSets'</span><span>
</span><span id="line-727"></span><span id="local-6989586621681156253"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#sSets"><span class="hs-identifier hs-type">sSets</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621681156253"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SymVal"><span class="hs-identifier hs-type">SymVal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156253"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SSet"><span class="hs-identifier hs-type">SSet</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156253"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-728"></span><span id="sSets"><span class="annot"><span class="annottext">sSets :: [String] -&gt; Symbolic [SSet a]
</span><a href="Data.SBV.Client.BaseIO.html#sSets"><span class="hs-identifier hs-var hs-var">sSets</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; Symbolic [SSet a]
forall a (m :: * -&gt; *).
(Ord a, SymVal a, MonadSymbolic m) =&gt;
[String] -&gt; m [SSet a]
</span><a href="Data.SBV.Core.Model.html#sSets"><span class="hs-identifier hs-var">Trans.sSets</span></a></span><span>
</span><span id="line-729"></span><span>
</span><span id="line-730"></span><span class="hs-comment">-- | Form the symbolic conjunction of a given list of boolean conditions. Useful in expressing</span><span>
</span><span id="line-731"></span><span class="hs-comment">-- problems with constraints, like the following:</span><span>
</span><span id="line-732"></span><span class="hs-comment">--</span><span>
</span><span id="line-733"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-734"></span><span class="hs-comment">--   sat $ do [x, y, z] &lt;- sIntegers [\&quot;x\&quot;, \&quot;y\&quot;, \&quot;z\&quot;]</span><span>
</span><span id="line-735"></span><span class="hs-comment">--            solve [x .&gt; 5, y + z .&lt; x]</span><span>
</span><span id="line-736"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-737"></span><span class="hs-comment">--</span><span>
</span><span id="line-738"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.solve'</span><span>
</span><span id="line-739"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#solve"><span class="hs-identifier hs-type">solve</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.SBV.Core.Data.html#SBool"><span class="hs-identifier hs-type">SBool</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBool"><span class="hs-identifier hs-type">SBool</span></a></span><span>
</span><span id="line-740"></span><span id="solve"><span class="annot"><span class="annottext">solve :: [SBool] -&gt; Symbolic SBool
</span><a href="Data.SBV.Client.BaseIO.html#solve"><span class="hs-identifier hs-var hs-var">solve</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SBool] -&gt; Symbolic SBool
forall (m :: * -&gt; *). MonadSymbolic m =&gt; [SBool] -&gt; m SBool
</span><a href="Data.SBV.Core.Model.html#solve"><span class="hs-identifier hs-var">Trans.solve</span></a></span><span>
</span><span id="line-741"></span><span>
</span><span id="line-742"></span><span class="hs-comment">-- | Introduce a soft assertion, with an optional penalty</span><span>
</span><span id="line-743"></span><span class="hs-comment">--</span><span>
</span><span id="line-744"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.assertWithPenalty'</span><span>
</span><span id="line-745"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#assertWithPenalty"><span class="hs-identifier hs-type">assertWithPenalty</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBool"><span class="hs-identifier hs-type">SBool</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Penalty"><span class="hs-identifier hs-type">Penalty</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-746"></span><span id="assertWithPenalty"><span class="annot"><span class="annottext">assertWithPenalty :: String -&gt; SBool -&gt; Penalty -&gt; Symbolic ()
</span><a href="Data.SBV.Client.BaseIO.html#assertWithPenalty"><span class="hs-identifier hs-var hs-var">assertWithPenalty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SBool -&gt; Penalty -&gt; Symbolic ()
forall (m :: * -&gt; *).
MonadSymbolic m =&gt;
String -&gt; SBool -&gt; Penalty -&gt; m ()
</span><a href="Data.SBV.Core.Model.html#assertWithPenalty"><span class="hs-identifier hs-var">Trans.assertWithPenalty</span></a></span><span>
</span><span id="line-747"></span><span>
</span><span id="line-748"></span><span class="hs-comment">-- | Minimize a named metric</span><span>
</span><span id="line-749"></span><span class="hs-comment">--</span><span>
</span><span id="line-750"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.minimize'</span><span>
</span><span id="line-751"></span><span id="local-6989586621681156246"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#minimize"><span class="hs-identifier hs-type">minimize</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Model.html#Metric"><span class="hs-identifier hs-type">Metric</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156246"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156246"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-752"></span><span id="minimize"><span class="annot"><span class="annottext">minimize :: String -&gt; SBV a -&gt; Symbolic ()
</span><a href="Data.SBV.Client.BaseIO.html#minimize"><span class="hs-identifier hs-var hs-var">minimize</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SBV a -&gt; Symbolic ()
forall a (m :: * -&gt; *).
(Metric a, MonadSymbolic m, SolverContext m) =&gt;
String -&gt; SBV a -&gt; m ()
</span><a href="Data.SBV.Core.Model.html#minimize"><span class="hs-identifier hs-var">Trans.minimize</span></a></span><span>
</span><span id="line-753"></span><span>
</span><span id="line-754"></span><span class="hs-comment">-- | Maximize a named metric</span><span>
</span><span id="line-755"></span><span class="hs-comment">--</span><span>
</span><span id="line-756"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.maximize'</span><span>
</span><span id="line-757"></span><span id="local-6989586621681156243"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#maximize"><span class="hs-identifier hs-type">maximize</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Model.html#Metric"><span class="hs-identifier hs-type">Metric</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156243"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SBV"><span class="hs-identifier hs-type">SBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156243"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-758"></span><span id="maximize"><span class="annot"><span class="annottext">maximize :: String -&gt; SBV a -&gt; Symbolic ()
</span><a href="Data.SBV.Client.BaseIO.html#maximize"><span class="hs-identifier hs-var hs-var">maximize</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SBV a -&gt; Symbolic ()
forall a (m :: * -&gt; *).
(Metric a, MonadSymbolic m, SolverContext m) =&gt;
String -&gt; SBV a -&gt; m ()
</span><a href="Data.SBV.Core.Model.html#maximize"><span class="hs-identifier hs-var">Trans.maximize</span></a></span><span>
</span><span id="line-759"></span><span>
</span><span id="line-760"></span><span class="hs-comment">-- Data.SBV.Core.Symbolic:</span><span>
</span><span id="line-761"></span><span>
</span><span id="line-762"></span><span class="hs-comment">-- | Convert a symbolic value to an SV, inside the Symbolic monad</span><span>
</span><span id="line-763"></span><span class="hs-comment">--</span><span>
</span><span id="line-764"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.svToSymSV'</span><span>
</span><span id="line-765"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#svToSymSV"><span class="hs-identifier hs-type">svToSymSV</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SVal"><span class="hs-identifier hs-type">SVal</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SV"><span class="hs-identifier hs-type">SV</span></a></span><span>
</span><span id="line-766"></span><span id="svToSymSV"><span class="annot"><span class="annottext">svToSymSV :: SVal -&gt; Symbolic SV
</span><a href="Data.SBV.Client.BaseIO.html#svToSymSV"><span class="hs-identifier hs-var hs-var">svToSymSV</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SVal -&gt; Symbolic SV
forall (m :: * -&gt; *). MonadSymbolic m =&gt; SVal -&gt; m SV
</span><a href="Data.SBV.Core.Symbolic.html#svToSymSV"><span class="hs-identifier hs-var">Trans.svToSymSV</span></a></span><span>
</span><span id="line-767"></span><span>
</span><span id="line-768"></span><span class="hs-comment">-- | Add a user specified axiom to the generated SMT-Lib file. The first argument is a mere</span><span>
</span><span id="line-769"></span><span class="hs-comment">-- string, use for commenting purposes. The second argument is intended to hold the multiple-lines</span><span>
</span><span id="line-770"></span><span class="hs-comment">-- of the axiom text as expressed in SMT-Lib notation. Note that we perform no checks on the axiom</span><span>
</span><span id="line-771"></span><span class="hs-comment">-- itself, to see whether it's actually well-formed or is sensical by any means.</span><span>
</span><span id="line-772"></span><span class="hs-comment">-- A separate formalization of SMT-Lib would be very useful here.</span><span>
</span><span id="line-773"></span><span class="hs-comment">--</span><span>
</span><span id="line-774"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.addAxiom'</span><span>
</span><span id="line-775"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#addAxiom"><span class="hs-identifier hs-type">addAxiom</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-776"></span><span id="addAxiom"><span class="annot"><span class="annottext">addAxiom :: String -&gt; [String] -&gt; Symbolic ()
</span><a href="Data.SBV.Client.BaseIO.html#addAxiom"><span class="hs-identifier hs-var hs-var">addAxiom</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; [String] -&gt; Symbolic ()
forall (m :: * -&gt; *). MonadSymbolic m =&gt; String -&gt; [String] -&gt; m ()
</span><a href="Data.SBV.Core.Symbolic.html#addAxiom"><span class="hs-identifier hs-var">Trans.addAxiom</span></a></span><span>
</span><span id="line-777"></span><span>
</span><span id="line-778"></span><span class="hs-comment">-- | Run a symbolic computation, and return a extra value paired up with the 'Result'</span><span>
</span><span id="line-779"></span><span class="hs-comment">--</span><span>
</span><span id="line-780"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.runSymbolic'</span><span>
</span><span id="line-781"></span><span id="local-6989586621681156236"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#runSymbolic"><span class="hs-identifier hs-type">runSymbolic</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SBVRunMode"><span class="hs-identifier hs-type">SBVRunMode</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156236"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621681156236"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Result"><span class="hs-identifier hs-type">Result</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-782"></span><span id="runSymbolic"><span class="annot"><span class="annottext">runSymbolic :: SBVRunMode -&gt; Symbolic a -&gt; IO (a, Result)
</span><a href="Data.SBV.Client.BaseIO.html#runSymbolic"><span class="hs-identifier hs-var hs-var">runSymbolic</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SBVRunMode -&gt; Symbolic a -&gt; IO (a, Result)
forall (m :: * -&gt; *) a.
MonadIO m =&gt;
SBVRunMode -&gt; SymbolicT m a -&gt; m (a, Result)
</span><a href="Data.SBV.Core.Symbolic.html#runSymbolic"><span class="hs-identifier hs-var">Trans.runSymbolic</span></a></span><span>
</span><span id="line-783"></span><span>
</span><span id="line-784"></span><span class="hs-comment">-- | Add a new option</span><span>
</span><span id="line-785"></span><span class="hs-comment">--</span><span>
</span><span id="line-786"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.addNewSMTOption'</span><span>
</span><span id="line-787"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#addNewSMTOption"><span class="hs-identifier hs-type">addNewSMTOption</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Control.Types.html#SMTOption"><span class="hs-identifier hs-type">SMTOption</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-788"></span><span id="addNewSMTOption"><span class="annot"><span class="annottext">addNewSMTOption :: SMTOption -&gt; Symbolic ()
</span><a href="Data.SBV.Client.BaseIO.html#addNewSMTOption"><span class="hs-identifier hs-var hs-var">addNewSMTOption</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SMTOption -&gt; Symbolic ()
forall (m :: * -&gt; *). MonadSymbolic m =&gt; SMTOption -&gt; m ()
</span><a href="Data.SBV.Core.Symbolic.html#addNewSMTOption"><span class="hs-identifier hs-var">Trans.addNewSMTOption</span></a></span><span>
</span><span id="line-789"></span><span>
</span><span id="line-790"></span><span class="hs-comment">-- | Handling constraints</span><span>
</span><span id="line-791"></span><span class="hs-comment">--</span><span>
</span><span id="line-792"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.imposeConstraint'</span><span>
</span><span id="line-793"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#imposeConstraint"><span class="hs-identifier hs-type">imposeConstraint</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SVal"><span class="hs-identifier hs-type">SVal</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-794"></span><span id="imposeConstraint"><span class="annot"><span class="annottext">imposeConstraint :: Bool -&gt; [(String, String)] -&gt; SVal -&gt; Symbolic ()
</span><a href="Data.SBV.Client.BaseIO.html#imposeConstraint"><span class="hs-identifier hs-var hs-var">imposeConstraint</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; [(String, String)] -&gt; SVal -&gt; Symbolic ()
forall (m :: * -&gt; *).
MonadSymbolic m =&gt;
Bool -&gt; [(String, String)] -&gt; SVal -&gt; m ()
</span><a href="Data.SBV.Core.Symbolic.html#imposeConstraint"><span class="hs-identifier hs-var">Trans.imposeConstraint</span></a></span><span>
</span><span id="line-795"></span><span>
</span><span id="line-796"></span><span class="hs-comment">-- | Add an optimization goal</span><span>
</span><span id="line-797"></span><span class="hs-comment">--</span><span>
</span><span id="line-798"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.addSValOptGoal'</span><span>
</span><span id="line-799"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#addSValOptGoal"><span class="hs-identifier hs-type">addSValOptGoal</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Objective"><span class="hs-identifier hs-type">Objective</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SVal"><span class="hs-identifier hs-type">SVal</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-800"></span><span id="addSValOptGoal"><span class="annot"><span class="annottext">addSValOptGoal :: Objective SVal -&gt; Symbolic ()
</span><a href="Data.SBV.Client.BaseIO.html#addSValOptGoal"><span class="hs-identifier hs-var hs-var">addSValOptGoal</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Objective SVal -&gt; Symbolic ()
forall (m :: * -&gt; *). MonadSymbolic m =&gt; Objective SVal -&gt; m ()
</span><a href="Data.SBV.Core.Symbolic.html#addSValOptGoal"><span class="hs-identifier hs-var">Trans.addSValOptGoal</span></a></span><span>
</span><span id="line-801"></span><span>
</span><span id="line-802"></span><span class="hs-comment">-- | Mark an interim result as an output. Useful when constructing Symbolic programs</span><span>
</span><span id="line-803"></span><span class="hs-comment">-- that return multiple values, or when the result is programmatically computed.</span><span>
</span><span id="line-804"></span><span class="hs-comment">--</span><span>
</span><span id="line-805"></span><span class="hs-comment">-- NB. For a version which generalizes over the underlying monad, see 'Data.SBV.Trans.outputSVal'</span><span>
</span><span id="line-806"></span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#outputSVal"><span class="hs-identifier hs-type">outputSVal</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#SVal"><span class="hs-identifier hs-type">SVal</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Core.Symbolic.html#Symbolic"><span class="hs-identifier hs-type">Symbolic</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-807"></span><span id="outputSVal"><span class="annot"><span class="annottext">outputSVal :: SVal -&gt; Symbolic ()
</span><a href="Data.SBV.Client.BaseIO.html#outputSVal"><span class="hs-identifier hs-var hs-var">outputSVal</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SVal -&gt; Symbolic ()
forall (m :: * -&gt; *). MonadSymbolic m =&gt; SVal -&gt; m ()
</span><a href="Data.SBV.Core.Symbolic.html#outputSVal"><span class="hs-identifier hs-var">Trans.outputSVal</span></a></span><span>
</span><span id="line-808"></span><span>
</span><span id="line-809"></span><span class="hs-comment">-- | Capturing non-matching instances for better error messages, conversions from sized</span><span>
</span><span id="line-810"></span><span class="hs-keyword">type</span><span> </span><span id="FromSizedErr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedErr"><span class="hs-identifier hs-var">FromSizedErr</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621681156224"><span class="annot"><a href="#local-6989586621681156224"><span class="hs-identifier hs-type">arg</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>     </span><span class="hs-special">'</span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="annot"><span class="hs-string">&quot;fromSized: Cannot convert from type: &quot;</span></span><span> </span><span class="hs-special">'</span><span class="hs-operator">:&lt;&gt;:</span><span> </span><span class="hs-special">'</span><span class="annot"><span class="hs-identifier hs-type">ShowType</span></span><span> </span><span class="annot"><a href="#local-6989586621681156224"><span class="hs-identifier hs-type">arg</span></a></span><span>
</span><span id="line-811"></span><span>                                </span><span class="hs-special">'</span><span class="hs-operator">:$$:</span><span> </span><span class="hs-special">'</span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="annot"><span class="hs-string">&quot;           Source type must be one of SInt N, SWord N, IntN N, WordN N&quot;</span></span><span>
</span><span id="line-812"></span><span>                                </span><span class="hs-special">'</span><span class="hs-operator">:$$:</span><span> </span><span class="hs-special">'</span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="annot"><span class="hs-string">&quot;           where N is 8, 16, 32, or 64.&quot;</span></span><span>
</span><span id="line-813"></span><span>
</span><span id="line-814"></span><span class="hs-comment">-- | Capturing non-matching instances for better error messages, conversions to sized</span><span>
</span><span id="line-815"></span><span class="hs-keyword">type</span><span> </span><span id="ToSizedErr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedErr"><span class="hs-identifier hs-var">ToSizedErr</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621681156222"><span class="annot"><a href="#local-6989586621681156222"><span class="hs-identifier hs-type">arg</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>      </span><span class="hs-special">'</span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="annot"><span class="hs-string">&quot;toSized: Cannot convert from type: &quot;</span></span><span> </span><span class="hs-special">'</span><span class="hs-operator">:&lt;&gt;:</span><span> </span><span class="hs-special">'</span><span class="annot"><span class="hs-identifier hs-type">ShowType</span></span><span> </span><span class="annot"><a href="#local-6989586621681156222"><span class="hs-identifier hs-type">arg</span></a></span><span>
</span><span id="line-816"></span><span>                              </span><span class="hs-special">'</span><span class="hs-operator">:$$:</span><span> </span><span class="hs-special">'</span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="annot"><span class="hs-string">&quot;          Source type must be one of Int8/16/32/64&quot;</span></span><span>
</span><span id="line-817"></span><span>                              </span><span class="hs-special">'</span><span class="hs-operator">:$$:</span><span> </span><span class="hs-special">'</span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="annot"><span class="hs-string">&quot;                                  OR Word8/16/32/64&quot;</span></span><span>
</span><span id="line-818"></span><span>                              </span><span class="hs-special">'</span><span class="hs-operator">:$$:</span><span> </span><span class="hs-special">'</span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="annot"><span class="hs-string">&quot;                                  OR their symbolic variants.&quot;</span></span><span>
</span><span id="line-819"></span><span>
</span><span id="line-820"></span><span class="hs-comment">-- | Capture the correspondence between sized and fixed-sized BVs</span><span>
</span><span id="line-821"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621681156221"><span class="annot"><a href="#local-6989586621681156221"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-822"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span>  </span><span class="annot"><span class="hs-number">8</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span>
</span><span id="line-823"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span> </span><span class="annot"><span class="hs-number">16</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word16</span></span><span>
</span><span id="line-824"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span> </span><span class="annot"><span class="hs-number">32</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word32</span></span><span>
</span><span id="line-825"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span> </span><span class="annot"><span class="hs-number">64</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word64</span></span><span>
</span><span id="line-826"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>   </span><span class="annot"><span class="hs-number">8</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int8</span></span><span>
</span><span id="line-827"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>  </span><span class="annot"><span class="hs-number">16</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int16</span></span><span>
</span><span id="line-828"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>  </span><span class="annot"><span class="hs-number">32</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int32</span></span><span>
</span><span id="line-829"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>  </span><span class="annot"><span class="hs-number">64</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int64</span></span><span>
</span><span id="line-830"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span>  </span><span class="annot"><span class="hs-number">8</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord8"><span class="hs-identifier hs-type">SWord8</span></a></span><span>
</span><span id="line-831"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span> </span><span class="annot"><span class="hs-number">16</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord16"><span class="hs-identifier hs-type">SWord16</span></a></span><span>
</span><span id="line-832"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span> </span><span class="annot"><span class="hs-number">32</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord32"><span class="hs-identifier hs-type">SWord32</span></a></span><span>
</span><span id="line-833"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span> </span><span class="annot"><span class="hs-number">64</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord64"><span class="hs-identifier hs-type">SWord64</span></a></span><span>
</span><span id="line-834"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>   </span><span class="annot"><span class="hs-number">8</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt8"><span class="hs-identifier hs-type">SInt8</span></a></span><span>
</span><span id="line-835"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>  </span><span class="annot"><span class="hs-number">16</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt16"><span class="hs-identifier hs-type">SInt16</span></a></span><span>
</span><span id="line-836"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>  </span><span class="annot"><span class="hs-number">32</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt32"><span class="hs-identifier hs-type">SInt32</span></a></span><span>
</span><span id="line-837"></span><span>   </span><span id="FromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-var">FromSized</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>  </span><span class="annot"><span class="hs-number">64</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt64"><span class="hs-identifier hs-type">SInt64</span></a></span><span>
</span><span id="line-838"></span><span>
</span><span id="line-839"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621681156220"><span class="annot"><a href="#local-6989586621681156220"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Constraint</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-840"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span>  </span><span class="annot"><span class="hs-number">8</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-841"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span> </span><span class="annot"><span class="hs-number">16</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-842"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span> </span><span class="annot"><span class="hs-number">32</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-843"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span> </span><span class="annot"><span class="hs-number">64</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-844"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>   </span><span class="annot"><span class="hs-number">8</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-845"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>  </span><span class="annot"><span class="hs-number">16</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-846"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>  </span><span class="annot"><span class="hs-number">32</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-847"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>  </span><span class="annot"><span class="hs-number">64</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-848"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span>  </span><span class="annot"><span class="hs-number">8</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-849"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span> </span><span class="annot"><span class="hs-number">16</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-850"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span> </span><span class="annot"><span class="hs-number">32</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-851"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span> </span><span class="annot"><span class="hs-number">64</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-852"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>   </span><span class="annot"><span class="hs-number">8</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-853"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>  </span><span class="annot"><span class="hs-number">16</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-854"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>  </span><span class="annot"><span class="hs-number">32</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-855"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>  </span><span class="annot"><span class="hs-number">64</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-856"></span><span>   </span><span id="FromSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-var">FromSizedCstr</span></a></span></span><span> </span><span id="local-6989586621681156219"><span class="annot"><a href="#local-6989586621681156219"><span class="hs-identifier hs-type hs-type">arg</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeError</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedErr"><span class="hs-identifier hs-type">FromSizedErr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156219"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-857"></span><span>
</span><span id="line-858"></span><span class="hs-comment">-- | Conversion from a sized BV to a fixed-sized bit-vector.</span><span>
</span><span id="line-859"></span><span class="hs-keyword">class</span><span> </span><span id="FromSizedBV"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-var">FromSizedBV</span></a></span></span><span> </span><span id="local-6989586621681156556"><span class="annot"><a href="#local-6989586621681156556"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-860"></span><span>   </span><span class="hs-comment">-- | Convert a sized bit-vector to the corresponding fixed-sized bit-vector,</span><span>
</span><span id="line-861"></span><span>   </span><span class="hs-comment">-- for instance 'SWord 16' to 'SWord16'. See also 'toSized'.</span><span>
</span><span id="line-862"></span><span>   </span><span id="fromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#fromSized"><span class="hs-identifier hs-type">fromSized</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621681156556"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-type">FromSized</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156556"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-863"></span><span>
</span><span id="line-864"></span><span>   </span><span class="hs-keyword">default</span><span> </span><span id="fromSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#fromSized"><span class="hs-identifier hs-type">fromSized</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-type">FromSized</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156556"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integral</span></span><span> </span><span class="annot"><a href="#local-6989586621681156556"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681156556"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSized"><span class="hs-identifier hs-type">FromSized</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156556"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-865"></span><span>   </span><span id="local-6989586621681156217"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#fromSized"><span class="hs-identifier hs-var hs-var">fromSized</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; FromSized a
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span></span><span>
</span><span id="line-866"></span><span>
</span><span id="line-867"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156215"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span>   </span><span class="annot"><span class="hs-number">8</span></span><span class="hs-special">)</span></span><span>
</span><span id="line-868"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156212"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span>  </span><span class="annot"><span class="hs-number">16</span></span><span class="hs-special">)</span></span><span>
</span><span id="line-869"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156210"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span>  </span><span class="annot"><span class="hs-number">32</span></span><span class="hs-special">)</span></span><span>
</span><span id="line-870"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156208"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span>  </span><span class="annot"><span class="hs-number">64</span></span><span class="hs-special">)</span></span><span>
</span><span id="line-871"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156206"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>    </span><span class="annot"><span class="hs-number">8</span></span><span class="hs-special">)</span></span><span>
</span><span id="line-872"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156204"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>   </span><span class="annot"><span class="hs-number">16</span></span><span class="hs-special">)</span></span><span>
</span><span id="line-873"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156202"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>   </span><span class="annot"><span class="hs-number">32</span></span><span class="hs-special">)</span></span><span>
</span><span id="line-874"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156200"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>   </span><span class="annot"><span class="hs-number">64</span></span><span class="hs-special">)</span></span><span>
</span><span id="line-875"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span>   </span><span class="annot"><span class="hs-number">8</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156198"><span class="annot"><span class="annottext">fromSized :: SWord 8 -&gt; FromSized (SWord 8)
</span><a href="#local-6989586621681156198"><span class="hs-identifier hs-var hs-var hs-var hs-var">fromSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SWord 8 -&gt; FromSized (SWord 8)
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-876"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span>  </span><span class="annot"><span class="hs-number">16</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156195"><span class="annot"><span class="annottext">fromSized :: SWord 16 -&gt; FromSized (SWord 16)
</span><a href="#local-6989586621681156195"><span class="hs-identifier hs-var hs-var hs-var hs-var">fromSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SWord 16 -&gt; FromSized (SWord 16)
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-877"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span>  </span><span class="annot"><span class="hs-number">32</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156193"><span class="annot"><span class="annottext">fromSized :: SWord 32 -&gt; FromSized (SWord 32)
</span><a href="#local-6989586621681156193"><span class="hs-identifier hs-var hs-var hs-var hs-var">fromSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SWord 32 -&gt; FromSized (SWord 32)
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-878"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span>  </span><span class="annot"><span class="hs-number">64</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156191"><span class="annot"><span class="annottext">fromSized :: SWord 64 -&gt; FromSized (SWord 64)
</span><a href="#local-6989586621681156191"><span class="hs-identifier hs-var hs-var hs-var hs-var">fromSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SWord 64 -&gt; FromSized (SWord 64)
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-879"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>    </span><span class="annot"><span class="hs-number">8</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156189"><span class="annot"><span class="annottext">fromSized :: SInt 8 -&gt; FromSized (SInt 8)
</span><a href="#local-6989586621681156189"><span class="hs-identifier hs-var hs-var hs-var hs-var">fromSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SInt 8 -&gt; FromSized (SInt 8)
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-880"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>   </span><span class="annot"><span class="hs-number">16</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156187"><span class="annot"><span class="annottext">fromSized :: SInt 16 -&gt; FromSized (SInt 16)
</span><a href="#local-6989586621681156187"><span class="hs-identifier hs-var hs-var hs-var hs-var">fromSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SInt 16 -&gt; FromSized (SInt 16)
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-881"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>   </span><span class="annot"><span class="hs-number">32</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156185"><span class="annot"><span class="annottext">fromSized :: SInt 32 -&gt; FromSized (SInt 32)
</span><a href="#local-6989586621681156185"><span class="hs-identifier hs-var hs-var hs-var hs-var">fromSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SInt 32 -&gt; FromSized (SInt 32)
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-882"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>   </span><span class="annot"><span class="hs-number">64</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156183"><span class="annot"><span class="annottext">fromSized :: SInt 64 -&gt; FromSized (SInt 64)
</span><a href="#local-6989586621681156183"><span class="hs-identifier hs-var hs-var hs-var hs-var">fromSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SInt 64 -&gt; FromSized (SInt 64)
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-883"></span><span id="local-6989586621681156182"><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPABLE</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedCstr"><span class="hs-identifier hs-type">FromSizedCstr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156182"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#FromSizedBV"><span class="hs-identifier hs-type">FromSizedBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156182"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156180"><span class="annot"><span class="annottext">fromSized :: arg -&gt; FromSized arg
</span><a href="#local-6989586621681156180"><span class="hs-identifier hs-var hs-var hs-var hs-var">fromSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; arg -&gt; FromSized arg
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="hs-string">&quot;unreachable&quot;</span></span></span><span>
</span><span id="line-884"></span><span>
</span><span id="line-885"></span><span class="hs-comment">-- | Capture the correspondence between fixed-sized and sized BVs</span><span>
</span><span id="line-886"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621681156178"><span class="annot"><a href="#local-6989586621681156178"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-887"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span>  </span><span class="annot"><span class="hs-number">8</span></span><span>
</span><span id="line-888"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word16</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span> </span><span class="annot"><span class="hs-number">16</span></span><span>
</span><span id="line-889"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word32</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span> </span><span class="annot"><span class="hs-number">32</span></span><span>
</span><span id="line-890"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word64</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#WordN"><span class="hs-identifier hs-type">WordN</span></a></span><span> </span><span class="annot"><span class="hs-number">64</span></span><span>
</span><span id="line-891"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int8</span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>   </span><span class="annot"><span class="hs-number">8</span></span><span>
</span><span id="line-892"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int16</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>  </span><span class="annot"><span class="hs-number">16</span></span><span>
</span><span id="line-893"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int32</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>  </span><span class="annot"><span class="hs-number">32</span></span><span>
</span><span id="line-894"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int64</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#IntN"><span class="hs-identifier hs-type">IntN</span></a></span><span>  </span><span class="annot"><span class="hs-number">64</span></span><span>
</span><span id="line-895"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord8"><span class="hs-identifier hs-type">SWord8</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span>  </span><span class="annot"><span class="hs-number">8</span></span><span>
</span><span id="line-896"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord16"><span class="hs-identifier hs-type">SWord16</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span> </span><span class="annot"><span class="hs-number">16</span></span><span>
</span><span id="line-897"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord32"><span class="hs-identifier hs-type">SWord32</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span> </span><span class="annot"><span class="hs-number">32</span></span><span>
</span><span id="line-898"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord64"><span class="hs-identifier hs-type">SWord64</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#SWord"><span class="hs-identifier hs-type">SWord</span></a></span><span> </span><span class="annot"><span class="hs-number">64</span></span><span>
</span><span id="line-899"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt8"><span class="hs-identifier hs-type">SInt8</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>   </span><span class="annot"><span class="hs-number">8</span></span><span>
</span><span id="line-900"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt16"><span class="hs-identifier hs-type">SInt16</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>  </span><span class="annot"><span class="hs-number">16</span></span><span>
</span><span id="line-901"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt32"><span class="hs-identifier hs-type">SInt32</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>  </span><span class="annot"><span class="hs-number">32</span></span><span>
</span><span id="line-902"></span><span>   </span><span id="ToSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-var">ToSized</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt64"><span class="hs-identifier hs-type">SInt64</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SBV.Core.Sized.html#SInt"><span class="hs-identifier hs-type">SInt</span></a></span><span>  </span><span class="annot"><span class="hs-number">64</span></span><span>
</span><span id="line-903"></span><span>
</span><span id="line-904"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621681156177"><span class="annot"><a href="#local-6989586621681156177"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Constraint</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-905"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-906"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word16</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-907"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word32</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-908"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word64</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-909"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int8</span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-910"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int16</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-911"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int32</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-912"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int64</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-913"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord8"><span class="hs-identifier hs-type">SWord8</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-914"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord16"><span class="hs-identifier hs-type">SWord16</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-915"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord32"><span class="hs-identifier hs-type">SWord32</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-916"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord64"><span class="hs-identifier hs-type">SWord64</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-917"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt8"><span class="hs-identifier hs-type">SInt8</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-918"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt16"><span class="hs-identifier hs-type">SInt16</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-919"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt32"><span class="hs-identifier hs-type">SInt32</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-920"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt64"><span class="hs-identifier hs-type">SInt64</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-921"></span><span>   </span><span id="ToSizedCstr"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-var">ToSizedCstr</span></a></span></span><span> </span><span id="local-6989586621681156176"><span class="annot"><a href="#local-6989586621681156176"><span class="hs-identifier hs-type hs-type">arg</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeError</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedErr"><span class="hs-identifier hs-type">ToSizedErr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156176"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-922"></span><span>
</span><span id="line-923"></span><span class="hs-comment">-- | Conversion from a fixed-sized BV to a sized bit-vector.</span><span>
</span><span id="line-924"></span><span class="hs-keyword">class</span><span> </span><span id="ToSizedBV"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-var">ToSizedBV</span></a></span></span><span> </span><span id="local-6989586621681156542"><span class="annot"><a href="#local-6989586621681156542"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-925"></span><span>   </span><span class="hs-comment">-- | Convert a fixed-sized bit-vector to the corresponding sized bit-vector,</span><span>
</span><span id="line-926"></span><span>   </span><span class="hs-comment">-- for instance 'SWord16' to 'SWord 16'. See also 'fromSized'.</span><span>
</span><span id="line-927"></span><span>   </span><span id="toSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#toSized"><span class="hs-identifier hs-type">toSized</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621681156542"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-type">ToSized</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156542"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-928"></span><span>
</span><span id="line-929"></span><span>   </span><span class="hs-keyword">default</span><span> </span><span id="toSized"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#toSized"><span class="hs-identifier hs-type">toSized</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-type">ToSized</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156542"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integral</span></span><span> </span><span class="annot"><a href="#local-6989586621681156542"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621681156542"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSized"><span class="hs-identifier hs-type">ToSized</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156542"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-930"></span><span>   </span><span id="local-6989586621681156174"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#toSized"><span class="hs-identifier hs-var hs-var">toSized</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; ToSized a
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span></span><span>
</span><span id="line-931"></span><span>
</span><span id="line-932"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156172"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span></span><span>
</span><span id="line-933"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156169"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word16</span></span></span><span>
</span><span id="line-934"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156167"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word32</span></span></span><span>
</span><span id="line-935"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156165"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word64</span></span></span><span>
</span><span id="line-936"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156163"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int8</span></span></span><span>
</span><span id="line-937"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156161"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int16</span></span></span><span>
</span><span id="line-938"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156159"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int32</span></span></span><span>
</span><span id="line-939"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621681156157"><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int64</span></span></span><span>
</span><span id="line-940"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord8"><span class="hs-identifier hs-type">SWord8</span></a></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156155"><span class="annot"><span class="annottext">toSized :: SWord8 -&gt; ToSized SWord8
</span><a href="#local-6989586621681156155"><span class="hs-identifier hs-var hs-var hs-var hs-var">toSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SWord8 -&gt; ToSized SWord8
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-941"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord16"><span class="hs-identifier hs-type">SWord16</span></a></span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156153"><span class="annot"><span class="annottext">toSized :: SWord16 -&gt; ToSized SWord16
</span><a href="#local-6989586621681156153"><span class="hs-identifier hs-var hs-var hs-var hs-var">toSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SWord16 -&gt; ToSized SWord16
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-942"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord32"><span class="hs-identifier hs-type">SWord32</span></a></span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156151"><span class="annot"><span class="annottext">toSized :: SWord32 -&gt; ToSized SWord32
</span><a href="#local-6989586621681156151"><span class="hs-identifier hs-var hs-var hs-var hs-var">toSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SWord32 -&gt; ToSized SWord32
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-943"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SWord64"><span class="hs-identifier hs-type">SWord64</span></a></span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156149"><span class="annot"><span class="annottext">toSized :: SWord64 -&gt; ToSized SWord64
</span><a href="#local-6989586621681156149"><span class="hs-identifier hs-var hs-var hs-var hs-var">toSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SWord64 -&gt; ToSized SWord64
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-944"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt8"><span class="hs-identifier hs-type">SInt8</span></a></span><span>   </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156147"><span class="annot"><span class="annottext">toSized :: SInt8 -&gt; ToSized SInt8
</span><a href="#local-6989586621681156147"><span class="hs-identifier hs-var hs-var hs-var hs-var">toSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SInt8 -&gt; ToSized SInt8
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-945"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt16"><span class="hs-identifier hs-type">SInt16</span></a></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156145"><span class="annot"><span class="annottext">toSized :: SInt16 -&gt; ToSized SInt16
</span><a href="#local-6989586621681156145"><span class="hs-identifier hs-var hs-var hs-var hs-var">toSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SInt16 -&gt; ToSized SInt16
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-946"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt32"><span class="hs-identifier hs-type">SInt32</span></a></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156143"><span class="annot"><span class="annottext">toSized :: SInt32 -&gt; ToSized SInt32
</span><a href="#local-6989586621681156143"><span class="hs-identifier hs-var hs-var hs-var hs-var">toSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SInt32 -&gt; ToSized SInt32
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-947"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><a href="Data.SBV.Core.Data.html#SInt64"><span class="hs-identifier hs-type">SInt64</span></a></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156141"><span class="annot"><span class="annottext">toSized :: SInt64 -&gt; ToSized SInt64
</span><a href="#local-6989586621681156141"><span class="hs-identifier hs-var hs-var hs-var hs-var">toSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SInt64 -&gt; ToSized SInt64
forall a b.
(Integral a, HasKind a, Num a, SymVal a, HasKind b, Num b,
 SymVal b) =&gt;
SBV a -&gt; SBV b
</span><a href="Data.SBV.Core.Model.html#sFromIntegral"><span class="hs-identifier hs-var">Trans.sFromIntegral</span></a></span><span>
</span><span id="line-948"></span><span id="local-6989586621681156140"><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPABLE</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedCstr"><span class="hs-identifier hs-type">ToSizedCstr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156140"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.SBV.Client.BaseIO.html#ToSizedBV"><span class="hs-identifier hs-type">ToSizedBV</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681156140"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681156138"><span class="annot"><span class="annottext">toSized :: arg -&gt; ToSized arg
</span><a href="#local-6989586621681156138"><span class="hs-identifier hs-var hs-var hs-var hs-var">toSized</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; arg -&gt; ToSized arg
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="hs-string">&quot;unreachable&quot;</span></span></span><span>
</span><span id="line-949"></span></pre></body></html>